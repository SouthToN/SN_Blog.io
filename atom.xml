<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://southton.github.io/starry</id>
    <title>Starry</title>
    <updated>2020-04-16T12:46:47.039Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://southton.github.io/starry"/>
    <link rel="self" href="https://southton.github.io/starry/atom.xml"/>
    <logo>https://southton.github.io/starry/images/avatar.png</logo>
    <icon>https://southton.github.io/starry/favicon.ico</icon>
    <rights>All rights reserved 2020, Starry</rights>
    <entry>
        <title type="html"><![CDATA[DP05 乘积最大子数组]]></title>
        <id>https://southton.github.io/starry/post/dp05/</id>
        <link href="https://southton.github.io/starry/post/dp05/">
        </link>
        <updated>2020-04-16T02:36:02.000Z</updated>
        <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p>
<p>示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>示例 2:<br>
输入: [-2,0,-1]<br>
输出: 0<br>
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">力扣：乘积最大子数组</a></p>
<p>思路：本题和<a href="https://southton.github.io/starry/post/dp04/">最大子序和</a>那道题目类似，不同在于乘法负负得正，当前的最小值可能遍历到下一个数时变成最大值，故这里需要使用两个数组，依然分三步:<br>
1、定义动态数组元素的含义，这一步一定要考虑清楚动态数组中的每一个元素具体表示什么含义</p>
<ul>
<li>mindp[i]:nums数组中前i个数(包括nums[i])乘积的最大值</li>
<li>maxdp[i]:nums数组中前i个数(包括nums[i])乘积的最小值</li>
</ul>
<p>2、找动态数组元素间的关系，这一步要讲可能的情况考虑周全，不容易发现关系时可以手动分析几步或者分析几个特殊例子寻找规律，针对本题可以发现一下规律：</p>
<pre><code>mindp[i] = Math.min(Math.min(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
maxdp[i] = Math.max(Math.max(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
</code></pre>
<p>3、给动态数组赋初值,这里即mindp[0]和maxdp[0]<br>
时间复杂度：O(n)<br>
空间复杂度：O(n)<br>
code1:</p>
<pre><code>class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;
        int[] mindp = new int[nums.length];
        int[] maxdp = new int[nums.length];
        mindp[0] = nums[0];
        maxdp[0] = nums[0];
        int max = nums[0];        
        for (int i = 1; i &lt; nums.length; i++) {
            mindp[i] = Math.min(Math.min(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
            maxdp[i] = Math.max(Math.max(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
            max = Math.max(maxdp[i], max);
        }
        return max;
    }
}
</code></pre>
<p>在上面的分析中，不难发现每次更新mindp[i]和maxdp[i]时只与mindp[i-1]有关maxdp[i-1]有关，因此可以不用数组，在每次更新mindp[i]和maxdp[i]之后，用变量将其暂存起来，供下次更新mindp[i]和maxdp[i]使用，优化后，时间复杂度不变，空间复杂度降为常O(1)。<br>
code2：</p>
<pre><code>class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;        
        int mindp = nums[0];
        int maxdp = nums[0];
        int max = nums[0];        
        for (int i = 1; i &lt; nums.length; i++) {
            int tmpmindp = Math.min(Math.min(mindp * nums[i], maxdp * nums[i]) , nums[i]);
            int tmpmaxdp = Math.max(Math.max(mindp * nums[i], maxdp * nums[i]) , nums[i]);
            max = Math.max(tmpmaxdp, max);
            mindp = tmpmindp;
            maxdp = tmpmaxdp;
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP04 最大子序和]]></title>
        <id>https://southton.github.io/starry/post/dp04/</id>
        <link href="https://southton.github.io/starry/post/dp04/">
        </link>
        <updated>2020-04-15T14:32:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最大子序和">最大子序和</h3>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br>
输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6<br>
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/maximum-subarray">力扣：最大子序和</a></p>
<p>思路：借助一维数组，三步走：<br>
1、定义dp[i]的含义，dp[i]表示遍历到nums[i]时最大连续子数组的和<br>
2、找出dp数组中元素之间的关系，dp[i]等于dp[i-1]+nums[i]与nums[i]中的大者<br>
3、找初始值，给dp数组赋初值，即nums[0]。<br>
由图中实例得dp为[-2,1,-2,4,3,5,6,1,5];<br>
时间复杂度与空间复杂度均为O(n);<br>
code：</p>
<pre><code>class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0) return 0;
        int [] dp = new int[nums.length]; //定义dp[i]
        dp[0]=nums[0]; // 赋初值
        int max = nums[0];//保存最大连续子数组的和
        for (int i = 1; i &lt; dp.length; i++) {
            dp[i] =(dp[i-1]+nums[i])&gt;nums[i]?(dp[i-1]+nums[i]):nums[i];
            max = max&gt;dp[i]?max:dp[i];
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP03  三角形最小路径和]]></title>
        <id>https://southton.github.io/starry/post/dp03/</id>
        <link href="https://southton.github.io/starry/post/dp03/">
        </link>
        <updated>2020-04-14T01:19:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="三角形最小路径和">三角形最小路径和</h3>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>
例如，给定三角形：<br>
[<br>
[2],<br>
[3,4],<br>
[6,5,7],<br>
[4,1,8,3]<br>
]<br>
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/triangle">力扣：三角形最小路径和</a></p>
<p>思路：本题依旧可以用二维数组解决，三步走，将三角形看作一个二维数组triangle[][]<br>
1、定义dp[i][j]的含义，dp[i][j]表示遍历到三角形第i行第j列的元素triangle[i][j]时的最短路径<br>
2、找出dp数组中元素之间的关系，分三种情况：</p>
<ul>
<li>每行的第一个元素：dp[i][j] = dp[i-1][j] +triangle[i][j]</li>
<li>每行的最后一个元素：dp[i][j] = dp[i-1][j-1] +triangle[i][j]</li>
<li>每行中间元素：dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) +triangle[i][j]</li>
</ul>
<p>3、找初始值，给dp数组赋初值，即三角形顶上元素triangle[0][0]。<br>
采用这种思路时间复杂度和空间复杂度均为O(n<sup>2)。通过以上思路分析，不难发现每次更新dp[i][j]时只与dp[i-1][j-1]和dp[i-1][j]有关，故可采用两个变量将dp[i-1][j-1]和dp[i-1][j]保存，采用一维数组即可完成以上3步过程，遍历完成后数组中的最小元素即为三角形的最小路径和。时间复杂度O(n</sup>2)、空间复杂度O(n)。<br>
code：</p>
<pre><code>class Solution {
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
        if(triangle.isEmpty()) return 0;
        int n = triangle.size(); //三角形的行数
        int [] dp= new int[n];
        dp[0]=triangle.get(0).get(0);//初始值
        int pre = 0;//保存dp[i-1][j-1]
        int cur;//保存dp[i-1][j]
        for (int i = 1; i &lt; n; i++) {
            List&lt;Integer&gt; item = triangle.get(i);//获取三角形的每一行元素
            for (int j = 0; j &lt;item.size(); j++) {
                cur = dp[j];
                if (j == 0) { // 每行第一个元素                   
                    dp[j] = cur + item.get(j);
                } else if (j == i) { // 每行最后一个元素                   
                    dp[j] = pre + item.get(j);
                } else {//中间元素
                    dp[j] = (cur&lt;pre?cur:pre) + item.get(j);
                }
                pre = cur;
            }
        }
        int min= Integer.MAX_VALUE;
        for (int i = 0; i &lt; dp.length; i++) {            
            min = min&gt;dp[i]?dp[i]:min;
        }
        return min;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP02 最长公共子序列]]></title>
        <id>https://southton.github.io/starry/post/dp02/</id>
        <link href="https://southton.github.io/starry/post/dp02/">
        </link>
        <updated>2020-04-13T03:09:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最长公共子序列">最长公共子序列</h3>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。<br>
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>
例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>
若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:<br>
输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;<br>
输出：3<br>
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</p>
<p>示例 2:<br>
输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;<br>
输出：3<br>
解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</p>
<p>示例 3:<br>
输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;<br>
输出：0<br>
解释：两个字符串没有公共子序列，返回 0。</p>
<p>提示:</p>
<ul>
<li>1 &lt;= text1.length &lt;= 1000</li>
<li>1 &lt;= text2.length &lt;= 1000</li>
<li>输入的字符串只含有小写英文字符。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/longest-common-subsequence">力扣：最长公共子序列</a></p>
<p>思路：利用二位数组，分三步走：<br>
1、定义数组元素的含义，dp[i][j]表示遍历到text1[i],text2[j]时最长公共子序列的长度<br>
2、找出数组元素间的关系式，这时候观察不容易发现，我们可以手动填充几个例子，便可以发现规律：</p>
<ul>
<li>test1[i]等于test1[j]时 dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] ) +1 ;</li>
<li>test1[i]等于test1[j]时 dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] ) ;</li>
</ul>
<p>3、找初始值，给dp数组赋初值。<br>
时间复杂度：O(m^n)<br>
空间复杂度：O(m*n)</p>
<p>code：</p>
<pre><code>class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1.length() == 0 || text2.length() == 0) return 0;
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m][n];
        // 初始值
        if (text1.charAt(0) == text2.charAt(0)) dp[0][0] = 1;        
        for (int i = 1; i &lt; n; i++) { // 给dp第一行赋初值
            if (text1.charAt(0) == text2.charAt(i)) {
                dp[0][i] = 1;
            } else {
                dp[0][i] = dp[0][i - 1];
            }
        }
        for (int i = 1; i &lt; m; i++) { // 给dp第一列赋初值
            if (text1.charAt(i) == text2.charAt(0)) {
                dp[i][0] = 1;
            } else {
                dp[i][0] = dp[i - 1][0];
            }
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i][j - 1] &gt; dp[i - 1][j] ? dp[i][j - 1] : dp[i - 1][j];
                if (text1.charAt(i) == text2.charAt(j)) {
                    dp[i][j] = dp[i][j] &gt; dp[i - 1][j - 1] ? dp[i][j] : dp[i - 1][j - 1] + 1;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP01  最长上升子序列]]></title>
        <id>https://southton.github.io/starry/post/dp01/</id>
        <link href="https://southton.github.io/starry/post/dp01/">
        </link>
        <updated>2020-04-12T02:07:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最长上升子序列">最长上升子序列</h3>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:<br>
输入: [10,9,2,5,3,7,101,18]<br>
输出: 4<br>
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
<p>说明:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(n^2) 。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">力扣：最长上升子序列</a></p>
<p>思路：结合示例分析：<br>
第0个数10                               dp[0] = 1  子序列为{10}<br>
第1个数9 前面没有比9小的数	    dp[1] = 1 子序列为{9}<br>
第2个数2 	                             dp[2] = 1  子序列为{2}<br>
第3个数5 前面有2比5小	          dp[3] = dp[2]+1 = 2  子序列为{2，5}<br>
第4个数3 前面只有2比3小	         dp[4] = dp[2]+1 = 2  子序列为{2，3}<br>
第5个数7  前面有2，5, 3比7小	    dp[5] =max( dp[2]， dp[3]， dp[4]) + 1=dp[4]+1=3  子序列为{2,3,7}<br>
第6个数101  前面有10,9,2,5,3,7比101小	dp[6] =max(dp[0],dp[1],dp[2],dp[3],dp[4],dp[5]) +1 =dp[5]+1 = 4 子序列为{2,3,7,101}<br>
第7个数18	 前面有10,9,2,5,3,7比18小 dp[7] =max(dp[0],dp[1],dp[2],dp[3],dp[4],dp[5]) +1 = dp[5]+1 = 4  子序列为{2,3,7,18}<br>
maxl = max(dp[i]) =dp[6] = 4<br>
时间复杂度：O(n^2)<br>
空间复杂度：O(n)<br>
代码如下<br>
code：</p>
<pre><code>class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length==0) return 0;
        int [] dp =new int[nums.length]; //dp[i]表示以nums[i]结尾的序列长度
        dp[0]=1;
        int max=1;//记录最长上升子序列长度
        for (int i = 1; i &lt; nums.length; i++) {
            int templen=0;  
            for (int j = 0; j &lt; nums.length; j++) {
                if(nums[i]&gt;nums[j]) templen =templen&gt;dp[j]?templen:dp[j];
            }
            dp[i] = templen+1;
            max = max&gt;dp[i]?max:dp[i];
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day38：字符串轮转 & 移除重复节点  ]]></title>
        <id>https://southton.github.io/starry/post/day38/</id>
        <link href="https://southton.github.io/starry/post/day38/">
        </link>
        <updated>2020-04-04T04:07:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-字符串轮转">一、字符串轮转</h3>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。<br>
示例1:<br>
输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;<br>
输出：True</p>
<p>示例2:<br>
输入：s1 = &quot;aa&quot;, &quot;aba&quot;<br>
输出：False</p>
<p>来源：<a href="https://leetcode-cn.com/problems/string-rotation-lcci">力扣：字符串轮转</a></p>
<p>思路：contains()方法<br>
code：</p>
<pre><code>class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        if(s1.equals(s2)) return true;
        s1 += s1;
        return s1.contains(s2);
    }
}
</code></pre>
<h3 id="二-移除重复节点">二、移除重复节点</h3>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:<br>
输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]</p>
<p>示例2:<br>
输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]</p>
<p>提示：</p>
<ul>
<li>链表长度在[0, 20000]范围内。</li>
<li>链表元素在[0, 20000]范围内。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci">力扣：移除重复节点</a>（LeetCode）</p>
<p>思路：暴力循环<br>
code：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {        
        ListNode tmp1 = head;
        while(tmp1!=null){
            ListNode tmp2 = tmp1;
            while(tmp2.next!=null){
                if (tmp2.next.val == tmp1.val)
                    tmp2.next = tmp2.next.next;
                else
                    tmp2 = tmp2.next;
            }
            tmp1=tmp1.next;
        }
        return head;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day37：旋转矩阵 & 零矩阵]]></title>
        <id>https://southton.github.io/starry/post/day37/</id>
        <link href="https://southton.github.io/starry/post/day37/">
        </link>
        <updated>2020-03-21T04:04:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-旋转矩阵">一、旋转矩阵</h3>
<p>给定一幅由N × N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。<br>
不占用额外内存空间能否做到？</p>
<p>示例 1:<br>
给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]</p>
<p>示例 2:<br>
给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]</p>
<p>来源：<a href="https://leetcode-cn.com/problems/rotate-matrix-lcci">旋转矩阵</a></p>
<p>思路：根据矩阵<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
]<br>
1移到3，3移到9，9移到7，7移到1。对应坐标变化可以发现规律：(x,y)--&gt;(x',y'):x'=y, y'=N-1-X,注意边界。<br>
code：</p>
<pre><code>class Solution {
    public void rotate(int[][] matrix) {
        int row=0,col=0,temp=0;
        int len = matrix.length;
        while(row&lt;(len+1)/2){
            col=0;
            while(col&lt;len/2){
                temp = matrix[row][col];
                matrix[row][col]=matrix[len-col-1][row];
                matrix[len-col-1][row]=matrix[len-1-row][len-1-col];
                matrix[len-1-row][len-1-col]=matrix[col][len-1-row];
                matrix[col][len-1-row]=temp;
                col++;
            }
            row++;
        }
    }
}
</code></pre>
<h3 id="二-零矩阵">二、零矩阵</h3>
<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。<br>
示例 1：<br>
输入：<br>
[<br>
[1,1,1],<br>
[1,0,1],<br>
[1,1,1]<br>
]<br>
输出：<br>
[<br>
[1,0,1],<br>
[0,0,0],<br>
[1,0,1]<br>
]</p>
<p>示例 2：<br>
输入：<br>
[<br>
[0,1,2,0],<br>
[3,4,5,2],<br>
[1,3,1,5]<br>
]<br>
输出：<br>
[<br>
[0,0,0,0],<br>
[0,4,5,0],<br>
[0,3,1,0]<br>
]</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zero-matrix-lcci">零矩阵</a></p>
<p>思路：遍历矩阵记录0所在行，所在列，遍历完成后，根据记录的行和列将矩阵对应行对应列的值设为0<br>
code：</p>
<pre><code>class Solution {
    public void setZeroes(int[][] matrix) {
        int[] r = new int[matrix.length];
        int[] c = new int[matrix[0].length];
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    r[i] = 1;
                    c[j] = 1;
                }

            }
        }
        for (int i = 0; i &lt; r.length; i++) {
            for (int j = 0; j &lt; c.length; j++) {
                if (r[i] != 0 &amp;&amp; c[j] != 0) setZeroe(matrix, i, j);
            }
        }
    }

    private void setZeroe(int[][] matrix, int row, int col) {
        for (int i = 0; i &lt; matrix[0].length; i++) {// 行设为0
            matrix[row][i] = 0;
        }
        for (int i = 0; i &lt; matrix.length; i++) {// 列设为0
            matrix[i][col] = 0;
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day36：一次编辑 & 字符串压缩]]></title>
        <id>https://southton.github.io/starry/post/day36/</id>
        <link href="https://southton.github.io/starry/post/day36/">
        </link>
        <updated>2020-03-20T10:18:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-一次编辑">一、一次编辑</h3>
<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<p>示例 1:<br>
输入:<br>
first = &quot;pale&quot;<br>
second = &quot;ple&quot;<br>
输出: True</p>
<p>示例 2:<br>
输入:<br>
first = &quot;pales&quot;<br>
second = &quot;pal&quot;<br>
输出: False</p>
<p>来源：<a href="https://leetcode-cn.com/problems/one-away-lcci/">力扣：一次编辑</a></p>
<p>思路1：分别考虑插入、删除、替换，其中删除可以当做在短的字符串中插入，因为只能编辑一次，则三种可能为lf+1=ls、lf = ls+1 、lf = ls（lf:字符串1长度、ls:字符串2长度），特别需要考虑边界情况，防止越界，这种做法代码冗余较高。<br>
code1：</p>
<pre><code>class Solution {
    public boolean oneEditAway(String first, String second) {
        if ((first.length() == 0 &amp;&amp; second.length() == 0) || (first.length() == 0 &amp;&amp; second.length() == 1)
                || (first.length() == 1 &amp;&amp; second.length() == 0))
            return true;
        int lf = first.length();
        int ls = second.length();
        boolean flag = false;
        if (lf + 1 == ls) { // 插入 lf+1=ls
            int count = 0;
            StringBuffer sBuffer = new StringBuffer();
            int f = 0, s = 0;
            while (f &lt; lf &amp;&amp; s &lt; ls) {
                if (first.charAt(f) == second.charAt(s)) {
                    sBuffer.append(first.charAt(f));
                    f++;
                    s++;
                } else {
                    sBuffer.append(second.charAt(s));
                    s++;
                    count++;
                }
            }
            if (sBuffer.length() &lt; ls) {
                sBuffer.append(second.charAt(ls - 1));
                count++;
            }
            String sb = new String(sBuffer);
            if (sb.equals(second) &amp;&amp; count == 1)
                return true;

        } else if (lf == ls + 1) { // 删除 lf = ls+1 ，可以看作在在短的字符串中插入
            int count = 0;
            StringBuffer sBuffer = new StringBuffer();
            int f = 0, s = 0;
            while (s &lt; ls &amp;&amp; f &lt; lf) {
                if (first.charAt(f) == second.charAt(s)) {
                    sBuffer.append(second.charAt(s));
                    f++;
                    s++;
                } else {
                    sBuffer.append(first.charAt(f));
                    f++;
                    count++;
                }
            }
            if (sBuffer.length() &lt; lf) {
                sBuffer.append(first.charAt(lf - 1));
                count++;
            }
            String sb = new String(sBuffer);
            if (sb.equals(first) &amp;&amp; count == 1)
                return true;

        } else if (lf == ls) { // 替换 lf = ls
            char[] sc = first.toCharArray();
            int count = 0;
            for (int i = 0; i &lt; lf; i++) {
                if (sc[i] != second.charAt(i)) {
                    sc[i] = second.charAt(i);
                    count++;
                }
            }
            if (String.valueOf(sc).equals(second) &amp;&amp; (count == 1) || (count == 0)) {
                return true;
            }
        }
        return flag;
    }
}
</code></pre>
<p>思路2：一次编辑，则first和second中至多有一个字符不相等<br>
code2：</p>
<pre><code>class Solution {
    public boolean oneEditAway(String first, String second) {
        int len = first.length() - second.length();
        if (len &gt; 1 || len &lt; -1) return false;//差值大于一则一次编辑无法完成  
        int count = 1;
        for (int i = 0, j = 0; i &lt; first.length() &amp;&amp; j &lt; second.length(); i++, j++) {
            if (first.charAt(i) != second.charAt(j)) {
                if (len == 1) { // second添加
                    j--;
                } else if (len == -1) { // second删除
                    i--;
                }
                count--;
            }
            if (count &lt; 0) return false;// 最多一次编辑 
        }
        return true;
    }
}
</code></pre>
<h3 id="二-字符串压缩">二、字符串压缩</h3>
<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<p>示例1:<br>
输入：&quot;aabcccccaaa&quot;<br>
输出：&quot;a2b1c5a3&quot;</p>
<p>示例2:<br>
输入：&quot;abbccd&quot;<br>
输出：&quot;abbccd&quot;<br>
解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</p>
<p>提示：字符串长度在[0, 50000]范围内。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/compress-string-lcci/">力扣：字符串压缩</a></p>
<p>思路：逐个统计字符出现次数，每次统计过程中，若前一个字符不等于当前字符，则将前一个字符以及次数添加到stringbuffer中。时间复杂度：O（N）空间复杂度O（1）。<br>
code：</p>
<pre><code>class Solution {
    public String compressString(String S) {
        if (S.length() == 0 || S == null) return S;
        StringBuffer sBuffer = new StringBuffer();
        char pre = S.charAt(0);
        int count = 1;
        for (int i = 1; i &lt; S.length(); i++) {
            char tmp = S.charAt(i);
            if (pre==tmp) {
                count++;
            } else {
                sBuffer.append(pre);
                sBuffer.append(count);
                pre = tmp;
                count=1;
            }
        }
        sBuffer.append(pre);
        sBuffer.append(count);
        if (sBuffer.length() &gt;= S.length()) return S;
        return sBuffer.toString(); 
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day35：URL化 & 回文排列]]></title>
        <id>https://southton.github.io/starry/post/day35/</id>
        <link href="https://southton.github.io/starry/post/day35/">
        </link>
        <updated>2020-03-19T03:37:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-url化">一、URL化</h3>
<p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）<br>
示例1:<br>
输入：&quot;Mr John Smith    &quot;, 13<br>
输出：&quot;Mr%20John%20Smith&quot;</p>
<p>示例2:<br>
输入：&quot;               &quot;, 5<br>
输出：&quot;%20%20%20%20%20&quot;<br>
来源：<a href="https://leetcode-cn.com/problems/string-to-url-lcci/">力扣：URL化</a><br>
思路：将字符串转为字符数组，然后循环添加到stringbuffer中，添加过程中判断如果是空格则向stringbuffer中添加&quot;%20&quot;,循环终止条件为length,最后将stringbuffer转为string。<br>
code：</p>
<pre><code>class Solution {
    public String replaceSpaces(String S, int length) {
        char [] cs = S.toCharArray();
        StringBuffer sBuffer = new StringBuffer();        
        for (int i = 0; i &lt; length; i++) {
            if(cs[i]!=' '){
                sBuffer.append(cs[i]);
            }else{
                sBuffer.append(&quot;%20&quot;);
            } 
        }
        return sBuffer.toString();
    }
}
</code></pre>
<h3 id="二-回文排列">二、回文排列</h3>
<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。<br>
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。<br>
回文串不一定是字典当中的单词。</p>
<p>示例1：<br>
输入：&quot;tactcoa&quot;<br>
输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）</p>
<p>来源：<a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">力扣：回文排列</a></p>
<p>思路：回文排列只有两种可能：</p>
<ul>
<li>只有一个字母出现奇数次，其他字母全部出现偶数次</li>
<li>全部出现偶数次，则可判定为回文。<br>
利用哈希表，不断添加删除，最终，哈希表中只剩下出现奇数次的字母，<br>
code：</li>
</ul>
<pre><code>class Solution {
    public boolean canPermutePalindrome(String s) {
        if (s.length() == 0) return true;
        Set strset = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            if (strset.contains(s.charAt(i))) {
                strset.remove(s.charAt(i));
            } else {
                strset.add(s.charAt(i));
            }
        }
        return strset.size()&lt;=1; //出现奇数次的字母只能是1个或0个
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day34：判定字符是否唯一 & 判定是否互为字符重排]]></title>
        <id>https://southton.github.io/starry/post/day34/</id>
        <link href="https://southton.github.io/starry/post/day34/">
        </link>
        <updated>2020-03-18T12:44:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-判定字符是否唯一">一、判定字符是否唯一</h3>
<p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。<br>
示例 1：<br>
输入: s = &quot;leetcode&quot;<br>
输出: false</p>
<p>示例 2：<br>
输入: s = &quot;abc&quot;<br>
输出: true<br>
限制：</p>
<ul>
<li>0 &lt;= len(s) &lt;= 100</li>
<li>如果你不使用额外的数据结构，会很加分。<br>
来源：<a href="https://leetcode-cn.com/problems/is-unique-lcci/">力扣：判定字符是否唯一</a></li>
</ul>
<p>思路1：最直接的方法，暴力遍历<br>
code1：</p>
<pre><code>class Solution {
    public boolean isUnique(String astr) {
        if(astr.length()==0) return true;
        for (int i = 0; i &lt; astr.length(); i++) {            
            for (int j = i+1; j &lt; astr.length(); j++) {
                if(astr.charAt(i)==astr.charAt(j))return false;            }
        }
        return true;
    }
}
</code></pre>
<p>思路2：利用hashset，如果字符唯一则最后hashset的长等于字符串的长度。<br>
code2：</p>
<pre><code>class Solution {
    public boolean isUnique(String astr) {
        if(astr.length()==0) return true;
        HashSet uni = new HashSet&lt;String&gt;();
        for (int i = 0; i &lt; astr.length(); i++) {
            uni.add(astr.charAt(i));
        }
        return uni.size()==astr.length();
    }
}
</code></pre>
<h3 id="二-判定是否互为字符重排">二、判定是否互为字符重排</h3>
<p>给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。<br>
示例 1：<br>
输入: s1 = &quot;abc&quot;, s2 = &quot;bca&quot;<br>
输出: true</p>
<p>示例 2：<br>
输入: s1 = &quot;abc&quot;, s2 = &quot;bad&quot;<br>
输出: false<br>
说明：</p>
<ul>
<li>0 &lt;= len(s1) &lt;= 100</li>
<li>0 &lt;= len(s2) &lt;= 100</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/check-permutation-lcci/">力扣：判定是否互为字符重排</a></p>
<p>思路1：将字符串转为字符串数组并排序，然后逐个比较排序后字符是否相等<br>
code1：</p>
<pre><code>class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        Arrays.sort(c1);
        Arrays.sort(c2);
        for (int i = 0; i &lt; c1.length; i++) {
            if(c1[i]!=c2[i]) return false;
        }
        return true;
    }
}
</code></pre>
<p>思路2：将字符串中的字符转换为ASCII码并求和，判断两个字符串的ASCII码和是否相等<br>
code2：</p>
<pre><code>class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int sum1=0,sum2=0;       
        for (int i = 0; i &lt; s1.length(); i++) {            
            sum1+=s1.charAt(i)-'a';
            sum2+=s2.charAt(i)-'a';
        }
        return sum1==sum2;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>