<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://southton.github.io/starry</id>
    <title>Starry</title>
    <updated>2020-04-20T09:50:58.783Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://southton.github.io/starry"/>
    <link rel="self" href="https://southton.github.io/starry/atom.xml"/>
    <logo>https://southton.github.io/starry/images/avatar.png</logo>
    <icon>https://southton.github.io/starry/favicon.ico</icon>
    <rights>All rights reserved 2020, Starry</rights>
    <entry>
        <title type="html"><![CDATA[DP08 打家劫舍]]></title>
        <id>https://southton.github.io/starry/post/dp08/</id>
        <link href="https://southton.github.io/starry/post/dp08/">
        </link>
        <updated>2020-04-20T08:10:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="打家劫舍">打家劫舍</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:<br>
输入: [1,2,3,1]<br>
输出: 4<br>
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>
     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2:<br>
输入: [2,7,9,3,1]<br>
输出: 12<br>
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/house-robber">力扣：打家劫舍</a></p>
<p>思路：采用动态规划<br>
1、定义动态数组的含义：dp[i]表示打劫到第i家时打劫的最大金额<br>
2、找动态数组间元素的关系，由题意不能连着打劫两家，故dp[i]为下面两种情况中的最大值</p>
<ul>
<li>1）打劫当前家，即dp[i-2]+nums[i]</li>
<li>2）不打劫当前家，即dp[i-1]</li>
</ul>
<pre><code>dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);
</code></pre>
<p>3、给动态数组元素赋初值，这里的初始值有两个，即第一家和第二家，打劫第一家时dp[0] =nums[0];，打劫第二家时，为第二家和第一家中的最大值dp[1] =Math.max(nums[0],nums[1]);<br>
时间复杂度和空间复杂度均为O(n)。<br>
code：</p>
<pre><code>class Solution {
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        int n = nums.length;
        int[] dp = new int[n+1];
        dp[0] =nums[0];
        dp[1] =Math.max(nums[0],nums[1]);
        for (int i = 2; i &lt; n; i++) {
            dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);
        }
        return dp[n-1];
    }
}
</code></pre>
<p>优化：上述思路可以发现每次在更新dp[i]的时候，只会用到dp[i-2]和nums[i],因此可以用两个变量，一个存储最大值，一个存储dp[i-2];时间复杂度O(n)，空间复杂度O(1)。<br>
code2：</p>
<pre><code>class Solution {
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;        
        int max= 0; //保存最大值
        int pre = 0;  //保存dp[i-2]
        for (int i : nums) {
            int tmp = max;
            max = Math.max(max, pre+i);
            pre = tmp;
        }  
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP07 俄罗斯套娃信封问题]]></title>
        <id>https://southton.github.io/starry/post/dp07/</id>
        <link href="https://southton.github.io/starry/post/dp07/">
        </link>
        <updated>2020-04-18T03:51:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="俄罗斯套娃信封问题">俄罗斯套娃信封问题</h3>
<p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>
请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br>
说明:不允许旋转信封。</p>
<p>示例:<br>
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>
输出: 3<br>
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">力扣：俄罗斯套娃信封问题</a></p>
<p>思路：排序后按最长子序列处理<br>
dp[i] 表示dp[i]表示第i个信封能套的最大信封数<br>
code：</p>
<pre><code>class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes.length &lt; 2) return envelopes.length;
        int n = envelopes.length;
        Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() {
            @Override
            public int compare(int[] o1, int[] o2) { // 自定义一个排序器按宽度进行升序排序
                if (o1[0] == o2[0])
                    return o2[1] - o1[1]; // 宽度相等时按高度降序排序
                return o1[0] - o2[0];
            }
        });
        int[] dp = new int[n];// dp[i]表示第i个信封能套的最大信封数        
        int max = 1;//记录最大值
        for (int i = 0; i &lt; n; i++) {
            dp[i] = 1;//初始化
            for (int j = 0; j &lt; i; j++) {
                if ( envelopes[i][1] &gt; envelopes[j][1]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            max = max&gt;dp[i]?max:dp[i];
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP06 鸡蛋掉落]]></title>
        <id>https://southton.github.io/starry/post/dp06/</id>
        <link href="https://southton.github.io/starry/post/dp06/">
        </link>
        <updated>2020-04-17T09:34:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="鸡蛋掉落">鸡蛋掉落</h3>
<p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>
你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。<br>
你的目标是确切地知道 F 的值是多少。<br>
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p>
<p>示例 1：<br>
输入：K = 1, N = 2<br>
输出：2<br>
解释：<br>
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>
如果它没碎，那么我们肯定知道 F = 2 。<br>
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</p>
<p>示例 2：<br>
输入：K = 2, N = 6<br>
输出：3</p>
<p>示例 3：<br>
输入：K = 3, N = 14<br>
输出：4</p>
<p>提示：</p>
<ul>
<li>1 &lt;= K &lt;= 100</li>
<li>1 &lt;= N &lt;= 10000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/super-egg-drop">力扣：鸡蛋掉落</a></p>
<p>思路：<br>
<img src="https://southton.github.io/starry/post-images/1587125917769.png" alt="" loading="lazy"><br>
1、定义动态数组元素的含义: dp[i][j] 表示i个鸡蛋j层楼时，确定 F 的值的最小移动次数<br>
2、找动态数组元素间的关系， dp[j][i] = dp[j][i - 1] (蛋没碎)+ dp[j - 1][i - 1] (蛋碎)+ 1;<br>
3、给动态数组赋初值,即没有蛋时dp[0][i] = 0<br>
code：</p>
<pre><code>class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        for (int i = 1; i &lt;= N; i++) {
            dp[0][i] = 0; // 赋初值
            for (int j = 1; j &lt;= K; j++) {
                dp[j][i] = dp[j][i - 1] + dp[j - 1][i - 1] + 1;
                if (dp[j][i] &gt;= N) return i;
            }
        }
        return N;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP05 乘积最大子数组]]></title>
        <id>https://southton.github.io/starry/post/dp05/</id>
        <link href="https://southton.github.io/starry/post/dp05/">
        </link>
        <updated>2020-04-16T02:36:02.000Z</updated>
        <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p>
<p>示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>示例 2:<br>
输入: [-2,0,-1]<br>
输出: 0<br>
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">力扣：乘积最大子数组</a></p>
<p>思路：本题和<a href="https://southton.github.io/starry/post/dp04/">最大子序和</a>那道题目类似，不同在于乘法负负得正，当前的最小值可能遍历到下一个数时变成最大值，故这里需要使用两个数组，依然分三步:<br>
1、定义动态数组元素的含义，这一步一定要考虑清楚动态数组中的每一个元素具体表示什么含义</p>
<ul>
<li>mindp[i]:nums数组中前i个数(包括nums[i])乘积的最大值</li>
<li>maxdp[i]:nums数组中前i个数(包括nums[i])乘积的最小值</li>
</ul>
<p>2、找动态数组元素间的关系，这一步要讲可能的情况考虑周全，不容易发现关系时可以手动分析几步或者分析几个特殊例子寻找规律，针对本题可以发现一下规律：</p>
<pre><code>mindp[i] = Math.min(Math.min(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
maxdp[i] = Math.max(Math.max(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
</code></pre>
<p>3、给动态数组赋初值,这里即mindp[0]和maxdp[0]<br>
时间复杂度：O(n)<br>
空间复杂度：O(n)<br>
code1:</p>
<pre><code>class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;
        int[] mindp = new int[nums.length];
        int[] maxdp = new int[nums.length];
        mindp[0] = nums[0];
        maxdp[0] = nums[0];
        int max = nums[0];        
        for (int i = 1; i &lt; nums.length; i++) {
            mindp[i] = Math.min(Math.min(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
            maxdp[i] = Math.max(Math.max(mindp[i - 1] * nums[i], maxdp[i - 1] * nums[i]) , nums[i]);
            max = Math.max(maxdp[i], max);
        }
        return max;
    }
}
</code></pre>
<p>在上面的分析中，不难发现每次更新mindp[i]和maxdp[i]时只与mindp[i-1]有关maxdp[i-1]有关，因此可以不用数组，在每次更新mindp[i]和maxdp[i]之后，用变量将其暂存起来，供下次更新mindp[i]和maxdp[i]使用，优化后，时间复杂度不变，空间复杂度降为常O(1)。<br>
code2：</p>
<pre><code>class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;        
        int mindp = nums[0];
        int maxdp = nums[0];
        int max = nums[0];        
        for (int i = 1; i &lt; nums.length; i++) {
            int tmpmindp = Math.min(Math.min(mindp * nums[i], maxdp * nums[i]) , nums[i]);
            int tmpmaxdp = Math.max(Math.max(mindp * nums[i], maxdp * nums[i]) , nums[i]);
            max = Math.max(tmpmaxdp, max);
            mindp = tmpmindp;
            maxdp = tmpmaxdp;
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP04 最大子序和]]></title>
        <id>https://southton.github.io/starry/post/dp04/</id>
        <link href="https://southton.github.io/starry/post/dp04/">
        </link>
        <updated>2020-04-15T14:32:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最大子序和">最大子序和</h3>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br>
输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6<br>
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/maximum-subarray">力扣：最大子序和</a></p>
<p>思路：借助一维数组，三步走：<br>
1、定义dp[i]的含义，dp[i]表示遍历到nums[i]时最大连续子数组的和<br>
2、找出dp数组中元素之间的关系，dp[i]等于dp[i-1]+nums[i]与nums[i]中的大者<br>
3、找初始值，给dp数组赋初值，即nums[0]。<br>
由图中实例得dp为[-2,1,-2,4,3,5,6,1,5];<br>
时间复杂度与空间复杂度均为O(n);<br>
code：</p>
<pre><code>class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0) return 0;
        int [] dp = new int[nums.length]; //定义dp[i]
        dp[0]=nums[0]; // 赋初值
        int max = nums[0];//保存最大连续子数组的和
        for (int i = 1; i &lt; dp.length; i++) {
            dp[i] =(dp[i-1]+nums[i])&gt;nums[i]?(dp[i-1]+nums[i]):nums[i];
            max = max&gt;dp[i]?max:dp[i];
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP03  三角形最小路径和]]></title>
        <id>https://southton.github.io/starry/post/dp03/</id>
        <link href="https://southton.github.io/starry/post/dp03/">
        </link>
        <updated>2020-04-14T01:19:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="三角形最小路径和">三角形最小路径和</h3>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>
例如，给定三角形：<br>
[<br>
[2],<br>
[3,4],<br>
[6,5,7],<br>
[4,1,8,3]<br>
]<br>
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/triangle">力扣：三角形最小路径和</a></p>
<p>思路：本题依旧可以用二维数组解决，三步走，将三角形看作一个二维数组triangle[][]<br>
1、定义dp[i][j]的含义，dp[i][j]表示遍历到三角形第i行第j列的元素triangle[i][j]时的最短路径<br>
2、找出dp数组中元素之间的关系，分三种情况：</p>
<ul>
<li>每行的第一个元素：dp[i][j] = dp[i-1][j] +triangle[i][j]</li>
<li>每行的最后一个元素：dp[i][j] = dp[i-1][j-1] +triangle[i][j]</li>
<li>每行中间元素：dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) +triangle[i][j]</li>
</ul>
<p>3、找初始值，给dp数组赋初值，即三角形顶上元素triangle[0][0]。<br>
采用这种思路时间复杂度和空间复杂度均为O(n<sup>2)。通过以上思路分析，不难发现每次更新dp[i][j]时只与dp[i-1][j-1]和dp[i-1][j]有关，故可采用两个变量将dp[i-1][j-1]和dp[i-1][j]保存，采用一维数组即可完成以上3步过程，遍历完成后数组中的最小元素即为三角形的最小路径和。时间复杂度O(n</sup>2)、空间复杂度O(n)。<br>
code：</p>
<pre><code>class Solution {
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
        if(triangle.isEmpty()) return 0;
        int n = triangle.size(); //三角形的行数
        int [] dp= new int[n];
        dp[0]=triangle.get(0).get(0);//初始值
        int pre = 0;//保存dp[i-1][j-1]
        int cur;//保存dp[i-1][j]
        for (int i = 1; i &lt; n; i++) {
            List&lt;Integer&gt; item = triangle.get(i);//获取三角形的每一行元素
            for (int j = 0; j &lt;item.size(); j++) {
                cur = dp[j];
                if (j == 0) { // 每行第一个元素                   
                    dp[j] = cur + item.get(j);
                } else if (j == i) { // 每行最后一个元素                   
                    dp[j] = pre + item.get(j);
                } else {//中间元素
                    dp[j] = (cur&lt;pre?cur:pre) + item.get(j);
                }
                pre = cur;
            }
        }
        int min= Integer.MAX_VALUE;
        for (int i = 0; i &lt; dp.length; i++) {            
            min = min&gt;dp[i]?dp[i]:min;
        }
        return min;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP02 最长公共子序列]]></title>
        <id>https://southton.github.io/starry/post/dp02/</id>
        <link href="https://southton.github.io/starry/post/dp02/">
        </link>
        <updated>2020-04-13T03:09:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最长公共子序列">最长公共子序列</h3>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。<br>
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>
例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>
若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:<br>
输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;<br>
输出：3<br>
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</p>
<p>示例 2:<br>
输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;<br>
输出：3<br>
解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</p>
<p>示例 3:<br>
输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;<br>
输出：0<br>
解释：两个字符串没有公共子序列，返回 0。</p>
<p>提示:</p>
<ul>
<li>1 &lt;= text1.length &lt;= 1000</li>
<li>1 &lt;= text2.length &lt;= 1000</li>
<li>输入的字符串只含有小写英文字符。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/longest-common-subsequence">力扣：最长公共子序列</a></p>
<p>思路：利用二位数组，分三步走：<br>
1、定义数组元素的含义，dp[i][j]表示遍历到text1[i],text2[j]时最长公共子序列的长度<br>
2、找出数组元素间的关系式，这时候观察不容易发现，我们可以手动填充几个例子，便可以发现规律：</p>
<ul>
<li>test1[i]等于test1[j]时 dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] ) +1 ;</li>
<li>test1[i]等于test1[j]时 dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] ) ;</li>
</ul>
<p>3、找初始值，给dp数组赋初值。<br>
时间复杂度：O(m^n)<br>
空间复杂度：O(m*n)</p>
<p>code：</p>
<pre><code>class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1.length() == 0 || text2.length() == 0) return 0;
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m][n];
        // 初始值
        if (text1.charAt(0) == text2.charAt(0)) dp[0][0] = 1;        
        for (int i = 1; i &lt; n; i++) { // 给dp第一行赋初值
            if (text1.charAt(0) == text2.charAt(i)) {
                dp[0][i] = 1;
            } else {
                dp[0][i] = dp[0][i - 1];
            }
        }
        for (int i = 1; i &lt; m; i++) { // 给dp第一列赋初值
            if (text1.charAt(i) == text2.charAt(0)) {
                dp[i][0] = 1;
            } else {
                dp[i][0] = dp[i - 1][0];
            }
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i][j - 1] &gt; dp[i - 1][j] ? dp[i][j - 1] : dp[i - 1][j];
                if (text1.charAt(i) == text2.charAt(j)) {
                    dp[i][j] = dp[i][j] &gt; dp[i - 1][j - 1] ? dp[i][j] : dp[i - 1][j - 1] + 1;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP01  最长上升子序列]]></title>
        <id>https://southton.github.io/starry/post/dp01/</id>
        <link href="https://southton.github.io/starry/post/dp01/">
        </link>
        <updated>2020-04-12T02:07:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最长上升子序列">最长上升子序列</h3>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:<br>
输入: [10,9,2,5,3,7,101,18]<br>
输出: 4<br>
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
<p>说明:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(n^2) 。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">力扣：最长上升子序列</a></p>
<p>思路：结合示例分析：<br>
第0个数10                               dp[0] = 1  子序列为{10}<br>
第1个数9 前面没有比9小的数	    dp[1] = 1 子序列为{9}<br>
第2个数2 	                             dp[2] = 1  子序列为{2}<br>
第3个数5 前面有2比5小	          dp[3] = dp[2]+1 = 2  子序列为{2，5}<br>
第4个数3 前面只有2比3小	         dp[4] = dp[2]+1 = 2  子序列为{2，3}<br>
第5个数7  前面有2，5, 3比7小	    dp[5] =max( dp[2]， dp[3]， dp[4]) + 1=dp[4]+1=3  子序列为{2,3,7}<br>
第6个数101  前面有10,9,2,5,3,7比101小	dp[6] =max(dp[0],dp[1],dp[2],dp[3],dp[4],dp[5]) +1 =dp[5]+1 = 4 子序列为{2,3,7,101}<br>
第7个数18	 前面有10,9,2,5,3,7比18小 dp[7] =max(dp[0],dp[1],dp[2],dp[3],dp[4],dp[5]) +1 = dp[5]+1 = 4  子序列为{2,3,7,18}<br>
maxl = max(dp[i]) =dp[6] = 4<br>
时间复杂度：O(n^2)<br>
空间复杂度：O(n)<br>
代码如下<br>
code：</p>
<pre><code>class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length==0) return 0;
        int [] dp =new int[nums.length]; //dp[i]表示以nums[i]结尾的序列长度
        dp[0]=1;
        int max=1;//记录最长上升子序列长度
        for (int i = 1; i &lt; nums.length; i++) {
            int templen=0;  
            for (int j = 0; j &lt; nums.length; j++) {
                if(nums[i]&gt;nums[j]) templen =templen&gt;dp[j]?templen:dp[j];
            }
            dp[i] = templen+1;
            max = max&gt;dp[i]?max:dp[i];
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day38：字符串轮转 & 移除重复节点  ]]></title>
        <id>https://southton.github.io/starry/post/day38/</id>
        <link href="https://southton.github.io/starry/post/day38/">
        </link>
        <updated>2020-04-04T04:07:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-字符串轮转">一、字符串轮转</h3>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。<br>
示例1:<br>
输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;<br>
输出：True</p>
<p>示例2:<br>
输入：s1 = &quot;aa&quot;, &quot;aba&quot;<br>
输出：False</p>
<p>来源：<a href="https://leetcode-cn.com/problems/string-rotation-lcci">力扣：字符串轮转</a></p>
<p>思路：contains()方法<br>
code：</p>
<pre><code>class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        if(s1.equals(s2)) return true;
        s1 += s1;
        return s1.contains(s2);
    }
}
</code></pre>
<h3 id="二-移除重复节点">二、移除重复节点</h3>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:<br>
输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]</p>
<p>示例2:<br>
输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]</p>
<p>提示：</p>
<ul>
<li>链表长度在[0, 20000]范围内。</li>
<li>链表元素在[0, 20000]范围内。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci">力扣：移除重复节点</a>（LeetCode）</p>
<p>思路：暴力循环<br>
code：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {        
        ListNode tmp1 = head;
        while(tmp1!=null){
            ListNode tmp2 = tmp1;
            while(tmp2.next!=null){
                if (tmp2.next.val == tmp1.val)
                    tmp2.next = tmp2.next.next;
                else
                    tmp2 = tmp2.next;
            }
            tmp1=tmp1.next;
        }
        return head;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day37：旋转矩阵 & 零矩阵]]></title>
        <id>https://southton.github.io/starry/post/day37/</id>
        <link href="https://southton.github.io/starry/post/day37/">
        </link>
        <updated>2020-03-21T04:04:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-旋转矩阵">一、旋转矩阵</h3>
<p>给定一幅由N × N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。<br>
不占用额外内存空间能否做到？</p>
<p>示例 1:<br>
给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]</p>
<p>示例 2:<br>
给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]</p>
<p>来源：<a href="https://leetcode-cn.com/problems/rotate-matrix-lcci">旋转矩阵</a></p>
<p>思路：根据矩阵<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
]<br>
1移到3，3移到9，9移到7，7移到1。对应坐标变化可以发现规律：(x,y)--&gt;(x',y'):x'=y, y'=N-1-X,注意边界。<br>
code：</p>
<pre><code>class Solution {
    public void rotate(int[][] matrix) {
        int row=0,col=0,temp=0;
        int len = matrix.length;
        while(row&lt;(len+1)/2){
            col=0;
            while(col&lt;len/2){
                temp = matrix[row][col];
                matrix[row][col]=matrix[len-col-1][row];
                matrix[len-col-1][row]=matrix[len-1-row][len-1-col];
                matrix[len-1-row][len-1-col]=matrix[col][len-1-row];
                matrix[col][len-1-row]=temp;
                col++;
            }
            row++;
        }
    }
}
</code></pre>
<h3 id="二-零矩阵">二、零矩阵</h3>
<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。<br>
示例 1：<br>
输入：<br>
[<br>
[1,1,1],<br>
[1,0,1],<br>
[1,1,1]<br>
]<br>
输出：<br>
[<br>
[1,0,1],<br>
[0,0,0],<br>
[1,0,1]<br>
]</p>
<p>示例 2：<br>
输入：<br>
[<br>
[0,1,2,0],<br>
[3,4,5,2],<br>
[1,3,1,5]<br>
]<br>
输出：<br>
[<br>
[0,0,0,0],<br>
[0,4,5,0],<br>
[0,3,1,0]<br>
]</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zero-matrix-lcci">零矩阵</a></p>
<p>思路：遍历矩阵记录0所在行，所在列，遍历完成后，根据记录的行和列将矩阵对应行对应列的值设为0<br>
code：</p>
<pre><code>class Solution {
    public void setZeroes(int[][] matrix) {
        int[] r = new int[matrix.length];
        int[] c = new int[matrix[0].length];
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    r[i] = 1;
                    c[j] = 1;
                }

            }
        }
        for (int i = 0; i &lt; r.length; i++) {
            for (int j = 0; j &lt; c.length; j++) {
                if (r[i] != 0 &amp;&amp; c[j] != 0) setZeroe(matrix, i, j);
            }
        }
    }

    private void setZeroe(int[][] matrix, int row, int col) {
        for (int i = 0; i &lt; matrix[0].length; i++) {// 行设为0
            matrix[row][i] = 0;
        }
        for (int i = 0; i &lt; matrix.length; i++) {// 列设为0
            matrix[i][col] = 0;
        }

    }
}
</code></pre>
]]></content>
    </entry>
</feed>