<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://southton.github.io/starry</id>
    <title>Starry</title>
    <updated>2020-03-14T14:18:02.104Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://southton.github.io/starry"/>
    <link rel="self" href="https://southton.github.io/starry/atom.xml"/>
    <logo>https://southton.github.io/starry/images/avatar.png</logo>
    <icon>https://southton.github.io/starry/favicon.ico</icon>
    <rights>All rights reserved 2020, Starry</rights>
    <entry>
        <title type="html"><![CDATA[Day30： 圆圈中最后剩下的数字 & 股票的最大利润]]></title>
        <id>https://southton.github.io/starry/post/day30/</id>
        <link href="https://southton.github.io/starry/post/day30/">
        </link>
        <updated>2020-03-14T04:36:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-圆圈中最后剩下的数字">一、圆圈中最后剩下的数字</h3>
<p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：<br>
输入: n = 5, m = 3<br>
输出: 3</p>
<p>示例 2：<br>
输入: n = 10, m = 17<br>
输出: 2<br>
限制：</p>
<ul>
<li>1 &lt;= n &lt;= 10^5</li>
<li>1 &lt;= m &lt;= 10^6</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">力扣：圆圈中最后剩下的数字</a></p>
<p>思路：约瑟夫环问题<br>
code：</p>
<pre><code>class Solution {
    public int lastRemaining(int n, int m) {
        if(n&lt;0||m&lt;0) return -1;
        int last = 0;
        for (int i =2; i &lt;= n; i++) {
            last=(last+m)%i;
        }
        return last;
    }
}
</code></pre>
<h3 id="二-股票的最大利润">二、股票的最大利润</h3>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>示例 2:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>限制：0 &lt;= 数组长度 &lt;= 10^5</p>
<p>来源：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof">力扣：股票的最大利润</a></p>
<p>思路1：直接遍历所有<br>
code1：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length&lt;=0) return 0;
        int max = 0;
        for (int i = 0; i &lt; prices.length; i++) {
            int temp = 0;
            for (int j = i + 1; j &lt; prices.length; j++) {
                temp = temp &gt; prices[j] - prices[i] ? temp : prices[j] - prices[i];
            }
            max = max &gt; temp ? max : temp;
        }
        return max;
    }
}
</code></pre>
<p>思路2：优化思路1，找到一个最小的temp，然后更新max<br>
code2：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length&lt;=0) return 0;
        int max = 0;
        int temp=prices[0];
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i]&lt;temp) {
                temp=prices[i];
            }else if(prices[i]-temp&gt;max){
                max=prices[i]-temp;
            }
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day29：n个骰子的点数 & 扑克牌中的顺子]]></title>
        <id>https://southton.github.io/starry/post/day29/</id>
        <link href="https://southton.github.io/starry/post/day29/">
        </link>
        <updated>2020-03-13T07:49:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-n个骰子的点数">一、n个骰子的点数</h3>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p>示例 1:<br>
输入: 1<br>
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</p>
<p>示例 2:<br>
输入: 2<br>
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<br>
限制：1 &lt;= n &lt;= 11</p>
<p>来源：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof">力扣：n个骰子的点数</a></p>
<p>思路：动态规划<br>
F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)<br>
code:</p>
<pre><code>class Solution {
    public double[] twoSum(int n) {
        if (n &lt; 1)   return new double[0];
        double[] dp = new double[6*n + 1];
        double[] pr = new double[5*n + 1];//可能的点数和
        double sum=Math.pow(6, n);        
        for (int i = 1; i &lt;= 6; i++) {
            dp[i]=1;
            pr[i-1]=1.0/6;            
        }
        for (int i = 2; i &lt;= n; i++) {  //控制骰子个数
            for (int j = n*6; j &gt;=1; j--) {
                int temp=0;
                for (int k = 1; k &lt;= 6; k++) {
                    temp+=j&gt;=k?dp[j-k]:0;
                }
                dp[j]=temp;
                if (i==n&amp;&amp;j&gt;=n) pr[j-i]=dp[j]/sum;                
            }
        }
        return pr;
    }
}
</code></pre>
<h3 id="二-扑克牌中的顺子">二、 扑克牌中的顺子</h3>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例 1:<br>
输入: [1,2,3,4,5]<br>
输出: True</p>
<p>示例 2:<br>
输入: [0,0,1,2,5]<br>
输出: True</p>
<p>限制：数组长度为 5 &amp; 数组的数取值为 [0, 13] .</p>
<p>来源：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">力扣：扑克牌中的顺子</a></p>
<p>思路：排序，统计数组中0的个数，数组中若有两个数相等则不能构成顺子，数组中不连续的两个数之间缺的数字个数必须小于等于数组中0的个数<br>
code：</p>
<pre><code>class Solution {
    public boolean isStraight(int[] nums) {
        if(nums.length&lt;5) return false;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt; 0 || nums[i] &gt; 13) return false;               
        }
        int zero = 0;
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 1; i++) {
            if (nums[i] == 0) {
                zero++;
                continue;
            }
            if (nums[i] == nums[i + 1]) return false;                
            if (nums[i] != nums[i + 1] + 1) zero -= nums[i + 1] - nums[i] - 1;                
        }
        return zero &gt;= 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day28：翻转单词顺序和左旋转字符串 & 滑动窗口的最大值和队列的最大值 ]]></title>
        <id>https://southton.github.io/starry/post/day28/</id>
        <link href="https://southton.github.io/starry/post/day28/">
        </link>
        <updated>2020-03-12T02:01:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-翻转单词顺序">一、翻转单词顺序</h3>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</p>
<p>示例 1：<br>
输入: &quot;the sky is blue&quot;<br>
输出: &quot;blue is sky the&quot;</p>
<p>示例 2：<br>
输入: &quot;  hello world!  &quot;<br>
输出: &quot;world! hello&quot;<br>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：<br>
输入: &quot;a good   example&quot;<br>
输出: &quot;example good a&quot;<br>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>
说明：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">力扣：翻转单词顺序</a></p>
<p>思路：trim（） 去除字符串前缀和后缀空格<br>
&quot;\s+&quot; 正则表达式(正则表达式中\s匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</p>
<ul>
<li>\f -&gt; 匹配一个换页</li>
<li>\n -&gt; 匹配一个换行符</li>
<li>\r -&gt; 匹配一个回车符</li>
<li>\t -&gt; 匹配一个制表符</li>
<li>\v -&gt; 匹配一个垂直制表符</li>
</ul>
<p>而“\s+”则表示匹配任意多个上面的字符。另因为&quot;&quot;在Java里是转义字符，所以在Java里用“\s+”.)<br>
code:</p>
<pre><code>class Solution {
    public String reverseWords(String s) {
        String[] str = s.trim().split(&quot;\\s+&quot;);
        int start=0;        
        int end = str.length - 1;
        while (start &lt; end) {
            String tmp = str[start];
            str[start] = str[end];
            str[end] = tmp;
            start++;
            end--;
        }              
        return String.join(&quot; &quot;, str);
    }
}
</code></pre>
<h3 id="二-左旋转字符串">二、左旋转字符串</h3>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
<p>示例 1：<br>
输入: s = &quot;abcdefg&quot;, k = 2<br>
输出: &quot;cdefgab&quot;</p>
<p>示例 2：<br>
输入: s = &quot;lrloseumgh&quot;, k = 6<br>
输出: &quot;umghlrlose&quot;</p>
<p>限制：1 &lt;= k &lt; s.length &lt;= 10000</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">力扣：左旋转字符串</a></p>
<p>思路1：用两个String数组<br>
code1：</p>
<pre><code>class Solution {
    public String reverseLeftWords(String s, int n) {
        if(n&lt;=0) return s;
        String [] str = s.split(&quot;&quot;); 
        int start=0; 
        String [] str2 = new String[str.length];              
        for (int i = n; i &lt; str.length; i++) {
            str2[start++]=str[i];
        }
        for (int i = 0; i &lt; n; i++) {
            str2[start++]=str[i];
        }  
        return String.join(&quot;&quot;, str2);
    }
}
</code></pre>
<p>思路2：<br>
code2：</p>
<pre><code>class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n) + s.substring(0, n);
    }
}
</code></pre>
<h3 id="三-滑动窗口的最大值">三、滑动窗口的最大值</h3>
<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:<br>
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>
输出: [3,3,5,5,6,7]<br>
解释:</p>
<pre><code>  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">力扣：滑动窗口的位置</a></p>
<p>思路：外层for控制窗口的移动，内层for负责找出最大值<br>
code：</p>
<pre><code>class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (k &lt;= 0) return nums;
        List result = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt;= nums.length-k; i++) {
            int max=nums[i];
            for (int j = i; j &lt; k+i; j++) {
                max=Math.max(max, nums[j]);
            }
            result.add(max);            
        }
        int[] results =new int[result.size()];
        for (int j = 0; j &lt; results.length; j++) {
            results[j]=(int)result.get(j);
        }
        return results;
    }
}
</code></pre>
<h3 id="四-队列的最大值">四、队列的最大值</h3>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>
若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：<br>
输入:<br>
[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]<br>
[[],[1],[2],[],[],[]]<br>
输出: [null,null,null,2,1,2]</p>
<p>示例 2：<br>
输入:<br>
[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]<br>
[[],[],[]]<br>
输出: [null,-1,-1]</p>
<p>限制：</p>
<ul>
<li>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</li>
<li>1 &lt;= value &lt;= 10^5</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">力扣：队列的最大值</a><br>
思路：<br>
code：</p>
<pre><code>class MaxQueue {
    private Deque&lt;Integer&gt; data = null;
    private Deque&lt;Integer&gt; max = null;    
    public MaxQueue() {
        data = new ArrayDeque&lt;&gt;();
        max = new ArrayDeque&lt;&gt;();
    }
    
    public int max_value() {
        if(max.isEmpty()) return -1;
        return max.peekFirst();
    }
    
    public void push_back(int value) {
        while(!max.isEmpty() &amp;&amp; value &gt; max.peekLast()) max.pollLast();        
        max.offerLast(value);
        data.offerLast(value);
    }
    
    public int pop_front() {
        if(data.isEmpty()) return -1;int value = data.pollFirst();
        if(max.peekFirst() == value) max.pollFirst();
        return value;
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day27：数组中数字出现的次数 & 和为s的两个数字]]></title>
        <id>https://southton.github.io/starry/post/day27/</id>
        <link href="https://southton.github.io/starry/post/day27/">
        </link>
        <updated>2020-03-11T04:37:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-数组中数字出现的次数">一、数组中数字出现的次数</h3>
<p>（1）数组中数字出现的次数 I<br>
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例 1：<br>
输入：nums = [4,1,4,6]<br>
输出：[1,6] 或 [6,1]</p>
<p>示例 2：<br>
输入：nums = [1,2,10,4,1,4,3,3]<br>
输出：[2,10] 或 [10,2]<br>
限制：</p>
<ul>
<li>2 &lt;= nums &lt;= 10000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">力扣：数组中数字出现的次数 I</a></p>
<p>思路：利用hashset<br>
code：</p>
<pre><code>class Solution {
    public int[] singleNumbers(int[] nums) {
       if (nums.length == 0) return new int[0];         
        HashSet hashset=new HashSet();
        for (int i = 0; i &lt; nums.length; i++) {
            if (hashset.contains(nums[i])) {
                hashset.remove(nums[i]);
            } else {
                hashset.add(nums[i]);
            }
        }       
        int [] result = new int[2];
        for (int i = 0; i &lt; hashset.size(); i++) {
            result[i]=Integer.parseInt(hashset.toArray()[i].toString());
        }
        return result;
    }
}
</code></pre>
<p>（2）数组中数字出现的次数 II<br>
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例 1：<br>
输入：nums = [3,4,3,3]<br>
输出：4</p>
<p>示例 2：<br>
输入：nums = [9,1,7,9,7,9,7]<br>
输出：1</p>
<p>限制：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 10000</li>
<li>1 &lt;= nums[i] &lt; 2^31</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">力扣：数组中数字出现的次数 II</a></p>
<p>思路1：循环遍历统计每个数字出现的次数<br>
code1：</p>
<pre><code>class Solution {
    public int singleNumber(int[] nums) {
        if (nums.length == 0) return 0;
        for (int i = 0; i &lt; nums.length; i++) {
            int count = 0;
            for (int j = 0; j &lt; nums.length; j++) {
                if (nums[i] == nums[j]) count++;                
            }
            if (count == 1) return nums[i];
        }
        return 0;
    }
}
</code></pre>
<p>思路2：借助hashmap统计每个数字出现的次数<br>
code2:</p>
<pre><code>class Solution {
    public int singleNumber(int[] nums) {
        if (nums.length == 0) return 0;
        Map&lt;Integer,Integer&gt; hm= new HashMap&lt;&gt;();
        for (int num : nums) {
            hm.put(num, hm.getOrDefault(num, 0)+1);
        }
        for (int num : nums) {
            if(hm.get(num)==1) return num;
        }
        return 0;
    }
}
</code></pre>
<h3 id="二-和为s的两个数字">二、和为s的两个数字</h3>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：<br>
输入：nums = [2,7,11,15], target = 9<br>
输出：[2,7] 或者 [7,2]</p>
<p>示例 2：<br>
输入：nums = [10,26,30,31,47,60], target = 40<br>
输出：[10,30] 或者 [30,10]</p>
<p>限制：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 10^5</li>
<li>1 &lt;= nums[i] &lt;= 10^6</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof">力扣：和为s的两个数字</a></p>
<p>思路1：直接遍历，由于递增排序，可以先找大的，然后遍历找小的<br>
code1：</p>
<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums.length == 0) return new int[0];            
        int[] result = new int[2];        
        for (int i = nums.length - 1; i &gt; 0; i--) {
            if (target - nums[i] &lt;= 0) continue; 
            for (int j = 0; j &lt; i; j++) {
                if (nums[j] == target-nums[i]) {
                    result[0] = nums[j];
                    result[1] = nums[i];                    
                    return result;
                }
            }
        }
        return result;
    }
}
</code></pre>
<p>思路2：利用双指针，从两端往中间扫描<br>
code2：</p>
<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums.length == 0) return new int[0];            
        int[] result = new int[2];  
        int start=0,end=nums.length-1;
        while(start&lt;end){
            int sum=nums[start]+nums[end];
            if (sum==target) {
                result[0]=nums[start];
                result[1]=nums[end];
            }
            if(sum&gt;target){
                end--;
            }else start++;
        }       
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day26：二叉搜索树的第k大节点 & 二叉树的深度和平衡二叉树]]></title>
        <id>https://southton.github.io/starry/post/day26/</id>
        <link href="https://southton.github.io/starry/post/day26/">
        </link>
        <updated>2020-03-10T07:32:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-二叉搜索树的第k大节点">一、二叉搜索树的第k大节点</h3>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例 1:<br>
输入: root = [3,1,4,null,2], k = 1<br>
<img src="https://southton.github.io/starry/post-images/1583995037571.png" alt="" loading="lazy"><br>
输出: 4</p>
<p>示例 2:<br>
输入: root = [5,3,6,2,4,null,null,1], k = 3<br>
<img src="https://southton.github.io/starry/post-images/1583995053171.png" alt="" loading="lazy"><br>
输出: 4<br>
限制：1 ≤ k ≤ 二叉搜索树元素个数</p>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">力扣：二叉搜索树的第k大节点</a></p>
<p>思路1：直接遍历，按右根左的顺序中序遍历整棵树<br>
code1:</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List tree = new ArrayList&lt;Integer&gt;();
    public int kthLargest(TreeNode root, int k) {
        if (root == null) return 0;
        rightFirst(root);
        int val = -1;
        for (int i = 0; i &lt; k; i++) {
            val = (int) tree.get(i);
        }
        return val;
    }
    public void rightFirst(TreeNode node) {
        if (node != null) {
            rightFirst(node.right);
            tree.add(node.val);
            rightFirst(node.left);
        }
    }
}
</code></pre>
<p>思路2：不需要遍历完，遍历到第k大即停止<br>
code2：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int count=0,val=0;
    public int kthLargest(TreeNode root, int k) {
    if (root == null)
        return 0;
    rightFirst(root,k);    
    return val;
    }

    public void rightFirst(TreeNode node,int k) {
        if (node != null) {
            rightFirst(node.right,k);
            if(++count==k){
                val=node.val;
                return;
            }
            rightFirst(node.left,k);
        }
    }
}
</code></pre>
<h3 id="二-二叉树的深度和平衡二叉树">二、二叉树的深度和平衡二叉树</h3>
<p>（1）二叉树的深度<br>
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
<img src="https://southton.github.io/starry/post-images/1583994937310.png" alt="" loading="lazy"><br>
返回它的最大深度 3 。<br>
提示：节点总数 &lt;= 10000</p>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">力扣：二叉树的深度</a></p>
<p>思路1：从根节点分别递归遍历左右子树<br>
code:</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
</code></pre>
<p>思路2：层序遍历<br>
code2：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        
        queue.add(root);
        TreeNode last=root;
        TreeNode cur;
        int count =0;
        while (!queue.isEmpty()) {
            cur = queue.poll();
            //System.out.print(root.val + &quot; &quot;);
            if (cur.left != null) queue.add(cur.left);
            if (cur.right != null) queue.add(cur.right);
            if(cur==last){
                last=queue.peekLast();
                ++count;
            }           
        }
        return count;
    }
}
</code></pre>
<p>（2）平衡二叉树<br>
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
<img src="https://southton.github.io/starry/post-images/1583994870436.png" alt="" loading="lazy"><br>
返回 true 。<br>
示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]<br>
<img src="https://southton.github.io/starry/post-images/1583994882199.png" alt="" loading="lazy"><br>
返回 false 。<br>
限制：1 &lt;= 树的结点个数 &lt;= 10000</p>
<p>来源：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">力扣：平衡二叉树</a></p>
<p>思路：递归计算每个节点的深度<br>
code:</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null) return true;
        if(Math.abs(maxDepth(root.left)-maxDepth(root.right))&lt;=1) return isBalanced(root.left)&amp;&amp;isBalanced(root.right);
        return false;
    }

    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day25：两个链表的第一个公共节点 & 0～n-1中缺失的数字]]></title>
        <id>https://southton.github.io/starry/post/day25/</id>
        <link href="https://southton.github.io/starry/post/day25/">
        </link>
        <updated>2020-03-09T05:27:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-两个链表的第一个公共节点">一、两个链表的第一个公共节点</h3>
<p>输入两个链表，找出它们的第一个公共节点。<br>
如下面的两个链表：<br>
<img src="https://southton.github.io/starry/post-images/1583994703207.png" alt="" loading="lazy"><br>
在节点 c1 开始相交。</p>
<p>示例 1：<br>
<img src="https://southton.github.io/starry/post-images/1583994712889.png" alt="" loading="lazy"><br>
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>
输出：Reference of the node with value = 8<br>
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：<br>
<img src="https://southton.github.io/starry/post-images/1583994723541.png" alt="" loading="lazy"><br>
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>
输出：Reference of the node with value = 2<br>
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br>
<img src="https://southton.github.io/starry/post-images/1583994735923.png" alt="" loading="lazy"><br>
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>
输出：null<br>
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>
解释：这两个链表不相交，因此返回 null。</p>
<p><code>注意：</code></p>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">力扣：两个链表的第一个公共节点</a></p>
<p>思路1：计算两个链表的长度差,从长度相等的地方开始找<br>
code1：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode lnA = headA;
        ListNode lnB = headB;
        int la = 0, lb = 0;
        while (lnA.next != null) {// 统计A的长度
            la++;
            lnA = lnA.next;
        }
        while (lnB.next != null) {// 统计B的长度
            lb++;
            lnB = lnB.next;
        }
        if (lnA != lnB) return null;// 如果最后一个节点不相等则无公共节点
        lnA = headA; //计算长度时修改过，此时重新赋值
        lnB = headB;
        int n = 0;
        if (la &gt; lb) { //移动到长度相等处
            n = la - lb;
            while (n-- &gt; 0) {
                lnA = lnA.next;
            }
        } else {
            n = lb - la;
            while (n-- &gt; 0) {
                lnB = lnB.next;
            }
        }
        while (lnA != lnB) {//从相等长度处开始找
            lnA = lnA == null ? null : lnA.next;
            lnB = lnB == null ? null : lnB.next;
        }
        return lnA;
    }
}
</code></pre>
<p>思路二：双指针，headA无重复部分长度+公共长度+headB无重复部分长度=headB无重复部分长度+公共长度+headA无重复部分长度<br>
code2：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
       if (headA == null || headB == null) return null;            
        ListNode ln1 = headA;
        ListNode ln2 = headB;
        while (ln1 != ln2) {
            ln1 = ln1 == null ? headB : ln1.next;
            ln2 = ln2 == null ? headA : ln2.next;
        }
        return ln1; 
    }
}
</code></pre>
<h3 id="二-0~n-1中缺失的数字">二、0～n-1中缺失的数字</h3>
<p>（1）在排序数组中查找数字 I<br>
统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:<br>
输入: nums = [5,7,7,8,8,10], target = 8<br>
输出: 2</p>
<p>示例 2:<br>
输入: nums = [5,7,7,8,8,10], target = 6<br>
输出: 0</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof">力扣：在排序数组中查找数字 I</a><br>
思路：<br>
code：</p>
<pre><code>class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 0) return 0;
        int count = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] == target) count++;
        }
        return count;
    }
}
</code></pre>
<p>（2）0～n-1中缺失的数字<br>
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:<br>
输入: [0,1,3]<br>
输出: 2</p>
<p>示例 2:<br>
输入: [0,1,2,3,4,5,6,7,9]<br>
输出: 8</p>
<p>来源：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">力扣：0～n-1中缺失的数字</a></p>
<p>思路：<br>
code：</p>
<pre><code>class Solution {
    public int missingNumber(int[] nums) {
        for(int i=0;i&lt;nums.length;i++){
            if(nums[i]!=i) return i;
        }
        return nums.length;
    }
}
</code></pre>
<p>os: 0～n-1中缺失的数字应该得用上排序这个规律</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day24：第一个只出现一次的字符 & 数组中的逆序对]]></title>
        <id>https://southton.github.io/starry/post/day24/</id>
        <link href="https://southton.github.io/starry/post/day24/">
        </link>
        <updated>2020-03-08T03:25:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-第一个只出现一次的字符">一、第一个只出现一次的字符</h3>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<p>示例:<br>
s = &quot;abaccdeff&quot;<br>
返回 &quot;b&quot;<br>
s = &quot;&quot;<br>
返回 &quot; &quot;</p>
<p>来源：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">力扣：第一个只出现一次的字符</a></p>
<p>思路1：直接遍历，时间复杂度O(n)，空间复杂度O(1)<br>
code1：</p>
<pre><code>class Solution {
    public char firstUniqChar(String s) {
        if (s.length() == 0) return ' ';
        int[] dict = new int[26];
        for (int i = 0; i &lt; s.length(); i++) {//统计每个字符出现的次数
            dict[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i &lt; s.length(); i++) {
            if (dict[s.charAt(i) - 'a'] == 1) {//找出第一个只出现一次的字符
                return s.charAt(i);
            }
        }
        return ' ';
    }
}
</code></pre>
<h3 id="二-数组中的逆序对">二、数组中的逆序对</h3>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例 1:<br>
输入: [7,5,6,4]<br>
输出: 5</p>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">力扣：数组中的逆序对</a></p>
<p>思路：利用归并排序的排序过程进行统计逆序对的个数<br>
code：</p>
<pre><code>class Solution {
    private long sum; // 统计逆序对的个数
    public int reversePairs(int[] nums) {
        if(nums.length==0) return 0;
        sum = 0;
        int l = 0;
        int r = nums.length - 1;
        divide(l, r, nums);
        return (int)sum;
    }    
    public void divide(int l, int r, int[] nums) {
        if (l != r) {
            int mid = (l + r) &gt;&gt; 1;
            divide(l, mid, nums);
            divide(mid + 1, r, nums);
            merge(l, r, mid, nums);
        }
    }
    public void merge(int l, int r, int mid, int[] nums) {
        int i = l; // 左区间的起点
        int j = mid + 1; // 右区间的起点
        int[] temp = new int[r - l + 1];
        int index = 0;
        while (i &lt;= mid &amp;&amp; j &lt;= r) {
            if (nums[i] &gt; nums[j]) {
                temp[index++] = nums[j++];
                sum += mid - i + 1; // 统计逆序对个数
            } else {
                temp[index++] = nums[i++];
            }
        }
        while (i &lt;= mid) temp[index++] = nums[i++];
        while (j &lt;= r) temp[index++] = nums[j++];
        index = 0;
        for (int k = l; k &lt;= r; k++) {
            nums[k] = temp[index++];
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day23：最长不含重复字符的子字符串 & 丑数]]></title>
        <id>https://southton.github.io/starry/post/day23/</id>
        <link href="https://southton.github.io/starry/post/day23/">
        </link>
        <updated>2020-03-07T06:23:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-最长不含重复字符的子字符串">一、最长不含重复字符的子字符串</h3>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>示例 1:<br>
输入: &quot;abcabcbb&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
<p>示例 2:<br>
输入: &quot;bbbbb&quot;<br>
输出: 1<br>
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</p>
<p>示例 3:<br>
输入: &quot;pwwkew&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>
请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">力扣：最长不含重复字符的子字符串</a></p>
<p>思路：动态规划，使用maxlist记录无重复字符的最长子串<br>
code：</p>
<pre><code>class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0) return 0;
        int maxLength=1;
		List&lt;Character&gt; maxlist = new ArrayList&lt;Character&gt;();
		maxlist.add(s.charAt(0));
		for(int i=1;i&lt;s.length();i++) {
			if(maxlist.contains(s.charAt(i))) {				
				int index = maxlist.indexOf(s.charAt(i)); 
				maxlist = maxlist.subList(index+1, maxlist.size());
				maxlist.add(s.charAt(i));
				maxLength = Math.max(maxLength, maxlist.size());
			}else {
				maxlist.add(s.charAt(i));
				maxLength = Math.max(maxLength, maxlist.size());
			}
		}
		return maxLength;
    }
}
</code></pre>
<h3 id="二-丑数">二、丑数</h3>
<p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:<br>
输入: n = 10<br>
输出: 12<br>
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>
说明:</p>
<ul>
<li>1 是丑数。</li>
<li>n 不超过1690。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/chou-shu-lcof">力扣：丑数</a></p>
<p>思路1：穷举<br>
code1：</p>
<pre><code>class Solution {
    public int nthUglyNumber(int n){
		if(n &lt;= 0) return 0;
		int number = 0;
		int uglyFound = 0;
		while(uglyFound &lt; n){
			number++;
			if(isUgly(number)) ++uglyFound;
		}
		return number;
	}

    public boolean isUgly(int number){
		while(number % 2 == 0) number/=2;			
		while(number % 3 == 0) number /=3;			
		while(number % 5 == 0) number /=5;			
		return number==1;
	}
}
</code></pre>
<p>思路2：找规律，一个丑数的下一个丑数总是等于它之前的 某个丑数乘2/某个丑数乘3/某个丑数乘5 中的最小值。<br>
code2：</p>
<pre><code>class Solution {
    public int nthUglyNumber(int n){
        if (n == 0) return 0;
        int p1 = 0, p2 = 0, p3 = 0;
        int[] ugly = new int[n];
        ugly[0] = 1;
        for (int i = 1; i &lt; n; i++) {
            ugly[i] = Math.min(ugly[p1] * 2, Math.min(ugly[p2] * 3, ugly[p3] * 5));
            if (ugly[i] == ugly[p1] * 2) p1++;                
            if (ugly[i] == ugly[p2] * 3) p2++;                
            if (ugly[i] == ugly[p3] * 5) p3++;                
        }
        return ugly[n - 1];
	}    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day22：把数字翻译成字符串 & 礼物的最大价值]]></title>
        <id>https://southton.github.io/starry/post/day22/</id>
        <link href="https://southton.github.io/starry/post/day22/">
        </link>
        <updated>2020-03-06T05:19:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-把数字翻译成字符串">一、把数字翻译成字符串</h3>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:<br>
输入: 12258<br>
输出: 5<br>
解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</p>
<p>来源：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">力扣：把数字翻译成字符串</a></p>
<p>思路：动态规划<br>
code：</p>
<pre><code>class Solution {
    public int translateNum(int num) {
        if (num&lt;0) return 0;
        char [] nums=String.valueOf(num).toCharArray();
        int len = nums.length;
        int[] dp =new int[len];
        int count = 0;
        for (int i = len-1; i &gt;=0 ; --i) {
            if(i&lt;len-1){
                count=dp[i+1];
            }else{
                count=1;
            }
            if(i&lt;len-1){
                int d1=nums[i]-'0';
                int d2 = nums[i+1]-'0';
                if (d1*10+d2&gt;=10 &amp;&amp; d1*10+d2&lt;=25) {
                    if (i&lt;len-2) {
                        count+=dp[i+2];
                    }else{
                        count+=1;
                    }
                }
            }
            dp[i]=count;
        }
        return dp[0];
    }
}
</code></pre>
<h3 id="二-礼物的最大价值">二、礼物的最大价值</h3>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 1:<br>
输入:<br>
[<br>
  [1,3,1],<br>
  [1,5,1],<br>
  [4,2,1]<br>
]<br>
输出: 12<br>
解释:<code>路径 1→3→5→2→1 可以拿到最多价值的礼物</code></p>
<p>来源：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">力扣：礼物的最大价值</a></p>
<p>思路：动态规划问题，维护一个和棋盘同样大小的二位数组，数组中保存的每个元素[i][j]为从[0][0]按照规则走到[i][j]的礼物价值和。<br>
code：</p>
<pre><code>class Solution {
    public int maxValue(int[][] grid) {
        int m=grid.length, n=grid[0].length;
        if(m==0&amp;&amp;n==0) return -1;
        int [][] max=new int[m+1][n+1];        
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                max[i][j]= Math.max(max[i-1][j], max[i][j-1])+grid[i-1][j-1];
            }
        }
        return max[m][n];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day21：数字序列中某一位的数字 & 把数组排成最小的数]]></title>
        <id>https://southton.github.io/starry/post/day21/</id>
        <link href="https://southton.github.io/starry/post/day21/">
        </link>
        <updated>2020-03-05T06:16:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-数字序列中某一位的数字">一、数字序列中某一位的数字</h3>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。<br>
请写一个函数，求任意第n位对应的数字。</p>
<p>示例 1：<br>
输入：n = 3<br>
输出：3</p>
<p>示例 2：<br>
输入：n = 11<br>
输出：0<br>
限制：</p>
<ul>
<li>0 &lt;= n &lt; 2^31</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof">力扣：数字序列中某一位的数字</a></p>
<p>思路：找规律，首先根据n先找到数字序列中对应的数字，其次判断是真实数字的哪一位数。n &lt; 2^31可以列出区间范围。</p>
<pre><code>数字序列                            总位数
1 --- 9                              9
10 --- 99                           90*2
100 --- 999                         900*3
    .                                 .                         
    .                                 .
</code></pre>
<p>code:</p>
<pre><code>class Solution {
    public int findNthDigit(int n) {
        int[] index = { 0, 10, 190, 2890, 38890, 488890, 5888890, 68888890, 788888890 };
        int[] values = { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000 };
        int idx = 8;
        while (idx &gt;= 0 &amp;&amp; index[idx] &gt; n) {
            idx--;
        }
        int numLength = idx + 1;
        int number = (n - index[idx]) / numLength + values[idx];//数字序列中的数
        int pos = (n - index[idx]) % numLength;
        return Integer.toString(number).charAt(pos) - '0';
    }
}
</code></pre>
<h3 id="二-把数组排成最小的数">二、把数组排成最小的数</h3>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例 1:<br>
输入: [10,2]<br>
输出: &quot;102&quot;</p>
<p>示例 2:<br>
输入: [3,30,34,5,9]<br>
输出: &quot;3033459&quot;</p>
<p>提示:<code>0 &lt; nums.length &lt;= 100</code><br>
说明:</p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">力扣：把数组排成最小的数</a></p>
<p>思路：排序<br>
code：</p>
<pre><code>class Solution {
    public String minNumber(int[] nums) {
        int len = nums.length;
        if(len == 0) return &quot;&quot;;
        String [] str = new String [len];
        for(int i = 0; i &lt; len; i++) str[i] = String.valueOf(nums[i]);
        Arrays.sort(str, new Comparator&lt;String&gt;(){
            public int compare(String s1, String s2){
                return (s1 + s2).compareTo(s2 + s1);
            }
        });
        StringBuffer stringBuffer = new StringBuffer();
        for(String s: str) stringBuffer.append(s);
        return stringBuffer.toString();
    }
}
</code></pre>
]]></content>
    </entry>
</feed>