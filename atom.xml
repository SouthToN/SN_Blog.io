<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://southton.github.io/starry</id>
    <title>Starry</title>
    <updated>2020-04-12T01:52:45.503Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://southton.github.io/starry"/>
    <link rel="self" href="https://southton.github.io/starry/atom.xml"/>
    <logo>https://southton.github.io/starry/images/avatar.png</logo>
    <icon>https://southton.github.io/starry/favicon.ico</icon>
    <rights>All rights reserved 2020, Starry</rights>
    <entry>
        <title type="html"><![CDATA[Day38：字符串轮转 & 移除重复节点  ]]></title>
        <id>https://southton.github.io/starry/post/day38/</id>
        <link href="https://southton.github.io/starry/post/day38/">
        </link>
        <updated>2020-04-04T04:07:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-字符串轮转">一、字符串轮转</h3>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。<br>
示例1:<br>
输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;<br>
输出：True</p>
<p>示例2:<br>
输入：s1 = &quot;aa&quot;, &quot;aba&quot;<br>
输出：False</p>
<p>来源：<a href="https://leetcode-cn.com/problems/string-rotation-lcci">力扣：字符串轮转</a></p>
<p>思路：contains()方法<br>
code：</p>
<pre><code>class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        if(s1.equals(s2)) return true;
        s1 += s1;
        return s1.contains(s2);
    }
}
</code></pre>
<h3 id="二-移除重复节点">二、移除重复节点</h3>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:<br>
输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]</p>
<p>示例2:<br>
输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]</p>
<p>提示：</p>
<ul>
<li>链表长度在[0, 20000]范围内。</li>
<li>链表元素在[0, 20000]范围内。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci">力扣：移除重复节点</a>（LeetCode）</p>
<p>思路：暴力循环<br>
code：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {        
        ListNode tmp1 = head;
        while(tmp1!=null){
            ListNode tmp2 = tmp1;
            while(tmp2.next!=null){
                if (tmp2.next.val == tmp1.val)
                    tmp2.next = tmp2.next.next;
                else
                    tmp2 = tmp2.next;
            }
            tmp1=tmp1.next;
        }
        return head;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day37：旋转矩阵 & 零矩阵]]></title>
        <id>https://southton.github.io/starry/post/day37/</id>
        <link href="https://southton.github.io/starry/post/day37/">
        </link>
        <updated>2020-03-21T04:04:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-旋转矩阵">一、旋转矩阵</h3>
<p>给定一幅由N × N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。<br>
不占用额外内存空间能否做到？</p>
<p>示例 1:<br>
给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]</p>
<p>示例 2:<br>
给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]</p>
<p>来源：<a href="https://leetcode-cn.com/problems/rotate-matrix-lcci">旋转矩阵</a></p>
<p>思路：根据矩阵<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
]<br>
1移到3，3移到9，9移到7，7移到1。对应坐标变化可以发现规律：(x,y)--&gt;(x',y'):x'=y, y'=N-1-X,注意边界。<br>
code：</p>
<pre><code>class Solution {
    public void rotate(int[][] matrix) {
        int row=0,col=0,temp=0;
        int len = matrix.length;
        while(row&lt;(len+1)/2){
            col=0;
            while(col&lt;len/2){
                temp = matrix[row][col];
                matrix[row][col]=matrix[len-col-1][row];
                matrix[len-col-1][row]=matrix[len-1-row][len-1-col];
                matrix[len-1-row][len-1-col]=matrix[col][len-1-row];
                matrix[col][len-1-row]=temp;
                col++;
            }
            row++;
        }
    }
}
</code></pre>
<h3 id="二-零矩阵">二、零矩阵</h3>
<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。<br>
示例 1：<br>
输入：<br>
[<br>
[1,1,1],<br>
[1,0,1],<br>
[1,1,1]<br>
]<br>
输出：<br>
[<br>
[1,0,1],<br>
[0,0,0],<br>
[1,0,1]<br>
]</p>
<p>示例 2：<br>
输入：<br>
[<br>
[0,1,2,0],<br>
[3,4,5,2],<br>
[1,3,1,5]<br>
]<br>
输出：<br>
[<br>
[0,0,0,0],<br>
[0,4,5,0],<br>
[0,3,1,0]<br>
]</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zero-matrix-lcci">零矩阵</a></p>
<p>思路：遍历矩阵记录0所在行，所在列，遍历完成后，根据记录的行和列将矩阵对应行对应列的值设为0<br>
code：</p>
<pre><code>class Solution {
    public void setZeroes(int[][] matrix) {
        int[] r = new int[matrix.length];
        int[] c = new int[matrix[0].length];
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    r[i] = 1;
                    c[j] = 1;
                }

            }
        }
        for (int i = 0; i &lt; r.length; i++) {
            for (int j = 0; j &lt; c.length; j++) {
                if (r[i] != 0 &amp;&amp; c[j] != 0) setZeroe(matrix, i, j);
            }
        }
    }

    private void setZeroe(int[][] matrix, int row, int col) {
        for (int i = 0; i &lt; matrix[0].length; i++) {// 行设为0
            matrix[row][i] = 0;
        }
        for (int i = 0; i &lt; matrix.length; i++) {// 列设为0
            matrix[i][col] = 0;
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day36：一次编辑 & 字符串压缩]]></title>
        <id>https://southton.github.io/starry/post/day36/</id>
        <link href="https://southton.github.io/starry/post/day36/">
        </link>
        <updated>2020-03-20T10:18:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-一次编辑">一、一次编辑</h3>
<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<p>示例 1:<br>
输入:<br>
first = &quot;pale&quot;<br>
second = &quot;ple&quot;<br>
输出: True</p>
<p>示例 2:<br>
输入:<br>
first = &quot;pales&quot;<br>
second = &quot;pal&quot;<br>
输出: False</p>
<p>来源：<a href="https://leetcode-cn.com/problems/one-away-lcci/">力扣：一次编辑</a></p>
<p>思路1：分别考虑插入、删除、替换，其中删除可以当做在短的字符串中插入，因为只能编辑一次，则三种可能为lf+1=ls、lf = ls+1 、lf = ls（lf:字符串1长度、ls:字符串2长度），特别需要考虑边界情况，防止越界，这种做法代码冗余较高。<br>
code1：</p>
<pre><code>class Solution {
    public boolean oneEditAway(String first, String second) {
        if ((first.length() == 0 &amp;&amp; second.length() == 0) || (first.length() == 0 &amp;&amp; second.length() == 1)
                || (first.length() == 1 &amp;&amp; second.length() == 0))
            return true;
        int lf = first.length();
        int ls = second.length();
        boolean flag = false;
        if (lf + 1 == ls) { // 插入 lf+1=ls
            int count = 0;
            StringBuffer sBuffer = new StringBuffer();
            int f = 0, s = 0;
            while (f &lt; lf &amp;&amp; s &lt; ls) {
                if (first.charAt(f) == second.charAt(s)) {
                    sBuffer.append(first.charAt(f));
                    f++;
                    s++;
                } else {
                    sBuffer.append(second.charAt(s));
                    s++;
                    count++;
                }
            }
            if (sBuffer.length() &lt; ls) {
                sBuffer.append(second.charAt(ls - 1));
                count++;
            }
            String sb = new String(sBuffer);
            if (sb.equals(second) &amp;&amp; count == 1)
                return true;

        } else if (lf == ls + 1) { // 删除 lf = ls+1 ，可以看作在在短的字符串中插入
            int count = 0;
            StringBuffer sBuffer = new StringBuffer();
            int f = 0, s = 0;
            while (s &lt; ls &amp;&amp; f &lt; lf) {
                if (first.charAt(f) == second.charAt(s)) {
                    sBuffer.append(second.charAt(s));
                    f++;
                    s++;
                } else {
                    sBuffer.append(first.charAt(f));
                    f++;
                    count++;
                }
            }
            if (sBuffer.length() &lt; lf) {
                sBuffer.append(first.charAt(lf - 1));
                count++;
            }
            String sb = new String(sBuffer);
            if (sb.equals(first) &amp;&amp; count == 1)
                return true;

        } else if (lf == ls) { // 替换 lf = ls
            char[] sc = first.toCharArray();
            int count = 0;
            for (int i = 0; i &lt; lf; i++) {
                if (sc[i] != second.charAt(i)) {
                    sc[i] = second.charAt(i);
                    count++;
                }
            }
            if (String.valueOf(sc).equals(second) &amp;&amp; (count == 1) || (count == 0)) {
                return true;
            }
        }
        return flag;
    }
}
</code></pre>
<p>思路2：一次编辑，则first和second中至多有一个字符不相等<br>
code2：</p>
<pre><code>class Solution {
    public boolean oneEditAway(String first, String second) {
        int len = first.length() - second.length();
        if (len &gt; 1 || len &lt; -1) return false;//差值大于一则一次编辑无法完成  
        int count = 1;
        for (int i = 0, j = 0; i &lt; first.length() &amp;&amp; j &lt; second.length(); i++, j++) {
            if (first.charAt(i) != second.charAt(j)) {
                if (len == 1) { // second添加
                    j--;
                } else if (len == -1) { // second删除
                    i--;
                }
                count--;
            }
            if (count &lt; 0) return false;// 最多一次编辑 
        }
        return true;
    }
}
</code></pre>
<h3 id="二-字符串压缩">二、字符串压缩</h3>
<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<p>示例1:<br>
输入：&quot;aabcccccaaa&quot;<br>
输出：&quot;a2b1c5a3&quot;</p>
<p>示例2:<br>
输入：&quot;abbccd&quot;<br>
输出：&quot;abbccd&quot;<br>
解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</p>
<p>提示：字符串长度在[0, 50000]范围内。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/compress-string-lcci/">力扣：字符串压缩</a></p>
<p>思路：逐个统计字符出现次数，每次统计过程中，若前一个字符不等于当前字符，则将前一个字符以及次数添加到stringbuffer中。时间复杂度：O（N）空间复杂度O（1）。<br>
code：</p>
<pre><code>class Solution {
    public String compressString(String S) {
        if (S.length() == 0 || S == null) return S;
        StringBuffer sBuffer = new StringBuffer();
        char pre = S.charAt(0);
        int count = 1;
        for (int i = 1; i &lt; S.length(); i++) {
            char tmp = S.charAt(i);
            if (pre==tmp) {
                count++;
            } else {
                sBuffer.append(pre);
                sBuffer.append(count);
                pre = tmp;
                count=1;
            }
        }
        sBuffer.append(pre);
        sBuffer.append(count);
        if (sBuffer.length() &gt;= S.length()) return S;
        return sBuffer.toString(); 
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day35：URL化 & 回文排列]]></title>
        <id>https://southton.github.io/starry/post/day35/</id>
        <link href="https://southton.github.io/starry/post/day35/">
        </link>
        <updated>2020-03-19T03:37:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-url化">一、URL化</h3>
<p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）<br>
示例1:<br>
输入：&quot;Mr John Smith    &quot;, 13<br>
输出：&quot;Mr%20John%20Smith&quot;</p>
<p>示例2:<br>
输入：&quot;               &quot;, 5<br>
输出：&quot;%20%20%20%20%20&quot;<br>
来源：<a href="https://leetcode-cn.com/problems/string-to-url-lcci/">力扣：URL化</a><br>
思路：将字符串转为字符数组，然后循环添加到stringbuffer中，添加过程中判断如果是空格则向stringbuffer中添加&quot;%20&quot;,循环终止条件为length,最后将stringbuffer转为string。<br>
code：</p>
<pre><code>class Solution {
    public String replaceSpaces(String S, int length) {
        char [] cs = S.toCharArray();
        StringBuffer sBuffer = new StringBuffer();        
        for (int i = 0; i &lt; length; i++) {
            if(cs[i]!=' '){
                sBuffer.append(cs[i]);
            }else{
                sBuffer.append(&quot;%20&quot;);
            } 
        }
        return sBuffer.toString();
    }
}
</code></pre>
<h3 id="二-回文排列">二、回文排列</h3>
<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。<br>
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。<br>
回文串不一定是字典当中的单词。</p>
<p>示例1：<br>
输入：&quot;tactcoa&quot;<br>
输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）</p>
<p>来源：<a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">力扣：回文排列</a></p>
<p>思路：回文排列只有两种可能：</p>
<ul>
<li>只有一个字母出现奇数次，其他字母全部出现偶数次</li>
<li>全部出现偶数次，则可判定为回文。<br>
利用哈希表，不断添加删除，最终，哈希表中只剩下出现奇数次的字母，<br>
code：</li>
</ul>
<pre><code>class Solution {
    public boolean canPermutePalindrome(String s) {
        if (s.length() == 0) return true;
        Set strset = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            if (strset.contains(s.charAt(i))) {
                strset.remove(s.charAt(i));
            } else {
                strset.add(s.charAt(i));
            }
        }
        return strset.size()&lt;=1; //出现奇数次的字母只能是1个或0个
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day34：判定字符是否唯一 & 判定是否互为字符重排]]></title>
        <id>https://southton.github.io/starry/post/day34/</id>
        <link href="https://southton.github.io/starry/post/day34/">
        </link>
        <updated>2020-03-18T12:44:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-判定字符是否唯一">一、判定字符是否唯一</h3>
<p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。<br>
示例 1：<br>
输入: s = &quot;leetcode&quot;<br>
输出: false</p>
<p>示例 2：<br>
输入: s = &quot;abc&quot;<br>
输出: true<br>
限制：</p>
<ul>
<li>0 &lt;= len(s) &lt;= 100</li>
<li>如果你不使用额外的数据结构，会很加分。<br>
来源：<a href="https://leetcode-cn.com/problems/is-unique-lcci/">力扣：判定字符是否唯一</a></li>
</ul>
<p>思路1：最直接的方法，暴力遍历<br>
code1：</p>
<pre><code>class Solution {
    public boolean isUnique(String astr) {
        if(astr.length()==0) return true;
        for (int i = 0; i &lt; astr.length(); i++) {            
            for (int j = i+1; j &lt; astr.length(); j++) {
                if(astr.charAt(i)==astr.charAt(j))return false;            }
        }
        return true;
    }
}
</code></pre>
<p>思路2：利用hashset，如果字符唯一则最后hashset的长等于字符串的长度。<br>
code2：</p>
<pre><code>class Solution {
    public boolean isUnique(String astr) {
        if(astr.length()==0) return true;
        HashSet uni = new HashSet&lt;String&gt;();
        for (int i = 0; i &lt; astr.length(); i++) {
            uni.add(astr.charAt(i));
        }
        return uni.size()==astr.length();
    }
}
</code></pre>
<h3 id="二-判定是否互为字符重排">二、判定是否互为字符重排</h3>
<p>给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。<br>
示例 1：<br>
输入: s1 = &quot;abc&quot;, s2 = &quot;bca&quot;<br>
输出: true</p>
<p>示例 2：<br>
输入: s1 = &quot;abc&quot;, s2 = &quot;bad&quot;<br>
输出: false<br>
说明：</p>
<ul>
<li>0 &lt;= len(s1) &lt;= 100</li>
<li>0 &lt;= len(s2) &lt;= 100</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/check-permutation-lcci/">力扣：判定是否互为字符重排</a></p>
<p>思路1：将字符串转为字符串数组并排序，然后逐个比较排序后字符是否相等<br>
code1：</p>
<pre><code>class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        Arrays.sort(c1);
        Arrays.sort(c2);
        for (int i = 0; i &lt; c1.length; i++) {
            if(c1[i]!=c2[i]) return false;
        }
        return true;
    }
}
</code></pre>
<p>思路2：将字符串中的字符转换为ASCII码并求和，判断两个字符串的ASCII码和是否相等<br>
code2：</p>
<pre><code>class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int sum1=0,sum2=0;       
        for (int i = 0; i &lt; s1.length(); i++) {            
            sum1+=s1.charAt(i)-'a';
            sum2+=s2.charAt(i)-'a';
        }
        return sum1==sum2;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day33：二叉搜索树的最近公共祖先 & 二叉树的最近公共祖先]]></title>
        <id>https://southton.github.io/starry/post/day33/</id>
        <link href="https://southton.github.io/starry/post/day33/">
        </link>
        <updated>2020-03-17T02:13:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-二叉搜索树的最近公共祖先-i">一、二叉搜索树的最近公共祖先 I</h3>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>
<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br>
<img src="https://southton.github.io/starry/post-images/1584411586366.png" alt="" loading="lazy"><br>
示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
<p>示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof">力扣：二叉搜索树的最近公共祖先 I</a></p>
<p>思路：对于二叉搜索树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，利用这一特性递归。<br>
code：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root==p || root == q)  return root;
        if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left, p, q);//p,q都在左子树
        if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right, p, q); //p,q都在右子树      
        return root;//p,q一个左一个右，则当前根即为公共祖先
    }
}
</code></pre>
<h3 id="二-二叉树的最近公共祖先-ii">二、二叉树的最近公共祖先 II</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>
<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br>
<img src="https://southton.github.io/starry/post-images/1584411737145.png" alt="" loading="lazy"><br>
示例 1:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof">力扣：二叉树的最近公共祖先 II</a></p>
<p>思路：递归<br>
code：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root==p || root == q)  return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);//递归左子树
        TreeNode right = lowestCommonAncestor(root.right, p, q);//递归右子树
        if(left==null) return right;//p,q在右子树
        if(right==null) return left;//p,q在左子树
        return root;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day32：构建乘积数组 & 把字符串转换成整数]]></title>
        <id>https://southton.github.io/starry/post/day32/</id>
        <link href="https://southton.github.io/starry/post/day32/">
        </link>
        <updated>2020-03-16T03:05:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-构建乘积数组">一、构建乘积数组</h3>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>示例:<br>
输入: [1,2,3,4,5]<br>
输出: [120,60,40,30,24]</p>
<p>提示：</p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li>a.length &lt;= 100000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">力扣：构建乘积数组</a></p>
<p>思路1：根据题目要求直接遍历，数组b的元素b[i]等于数组a中除a[i]外所有元素的乘积，也等于a中所有元素乘积除a[i]，又题目要求不能使用除法，故只能采用前者的思路，但是这样时间复杂度较高O(N^2)，力扣无法通过<br>
code1：</p>
<pre><code>class Solution {
    public int[] constructArr(int[] a) {
        if (a.length == 0) return new int[0];
        int len = a.length;
        int[] b = new int[len];
        int cur=0;
        while(cur&lt;len){
            int temp=1;
            for (int i = 0; i &lt; len; i++) {
                if(i!=cur) temp*=a[i];
            }            
            b[cur]=temp;
            cur++;
        }        
        return b;
    }
}
</code></pre>
<p>思路2：优化，数组b的元素b[i]等于数组a中除a[i]外所有元素的乘积，据此可将数组a从a[i]分左右两部分，b[i]就等于a[i]左边的累积结果乘右边累积结果,时间复杂度O（2N）。<br>
code2:</p>
<pre><code>class Solution {
    public int[] constructArr(int[] a) {
        if (a.length == 0) return new int[0];            
        int len = a.length;
        int[] b = new int[len];
        int temp = 1;// 左边累乘
        for (int i = 0; i &lt; len; i++) {
            b[i] = temp;
            temp *= a[i];
        }
        temp = 1;// 右边累乘
        for (int i = len - 1; i &gt;= 0; i--) {
            b[i] *= temp;
            temp *= a[i];
        }
        return b;
    }
}
</code></pre>
<h3 id="二-把字符串转换成整数">二、把字符串转换成整数</h3>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。<br>
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>
<code>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</code><br>
在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>
说明：<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:<br>
输入: &quot;42&quot;<br>
输出: 42</p>
<p>示例 2:<br>
输入: &quot;   -42&quot;<br>
输出: -42<br>
解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p>示例 3:<br>
输入: &quot;4193 with words&quot;<br>
输出: 4193<br>
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</p>
<p>示例 4:<br>
输入: &quot;words and 987&quot;<br>
输出: 0<br>
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。</p>
<p>示例 5:<br>
输入: &quot;-91283472332&quot;<br>
输出: -2147483648<br>
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">力扣：把字符串转换成整数</a></p>
<p>思路：注意考虑多种情况，例如符号，其他字符，溢出<br>
code：</p>
<pre><code>class Solution {
    public int strToInt(String str) {
        if (str==null||str.length() == 0) return 0;
        int len = str.length();
        int i = 0;
        boolean flag = true; // true:+,false:-
        while (i&lt;len&amp;&amp;str.charAt(i) == ' ' &amp;&amp; i &lt; len) {//去空格
            i++;
        }
        if(i&lt;len&amp;&amp; (str.charAt(i) == '+' || str.charAt(i) == '-')) {//判断正负            
            if (str.charAt(i) == '-')
                flag = false;
            i++;
        }
        long num = 0;
        while (i &lt; len &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') {//转换同时判断是否溢出
            num = num * 10 + str.charAt(i) - '0';            
            long temp = flag ? num : -num;
            if (temp &lt;= Integer.MIN_VALUE)
                return Integer.MIN_VALUE;
            if (temp &gt;= Integer.MAX_VALUE)
                return Integer.MAX_VALUE;
            i++;
        }        
        return (int) (flag?num:-num);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day31：求1+2+…+n & 不用加减乘除做加法]]></title>
        <id>https://southton.github.io/starry/post/day31/</id>
        <link href="https://southton.github.io/starry/post/day31/">
        </link>
        <updated>2020-03-15T03:32:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-求12n">一、求1+2+…+n</h3>
<p>求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：<br>
输入: n = 3<br>
输出: 6</p>
<p>示例 2：<br>
输入: n = 9<br>
输出: 45</p>
<p>限制：</p>
<ul>
<li>1 &lt;= n &lt;= 10000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof">力扣：求1+2+…+n</a></p>
<p>思路：使用递归，条件与 &amp;&amp; 在第一个条件语句为 false 的情况下不会去执行第二个条件语句。<br>
code：</p>
<pre><code>class Solution {
    public int sumNums(int n) {
        // return n*(n+1)/2;
        int sum = n;
        boolean b = (n &gt; 0) &amp;&amp; ((sum += sumNums(n - 1)) &gt; 0);
        return sum;
    }
}
</code></pre>
<h3 id="二-不用加减乘除做加法">二、不用加减乘除做加法</h3>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>示例:<br>
输入: a = 1, b = 1<br>
输出: 2</p>
<p>提示：</p>
<ul>
<li>a, b 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof">力扣：不用加减乘除做加法</a></p>
<p>思路：位运算<br>
code：</p>
<pre><code>class Solution {
    public int add(int a, int b) {
        while(b != 0){
            int temp = a ^ b; //按位异或
            b = (a &amp; b) &lt;&lt; 1; //进位
            a = temp;
        }
        return a;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day30： 圆圈中最后剩下的数字 & 股票的最大利润]]></title>
        <id>https://southton.github.io/starry/post/day30/</id>
        <link href="https://southton.github.io/starry/post/day30/">
        </link>
        <updated>2020-03-14T04:36:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-圆圈中最后剩下的数字">一、圆圈中最后剩下的数字</h3>
<p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：<br>
输入: n = 5, m = 3<br>
输出: 3</p>
<p>示例 2：<br>
输入: n = 10, m = 17<br>
输出: 2<br>
限制：</p>
<ul>
<li>1 &lt;= n &lt;= 10^5</li>
<li>1 &lt;= m &lt;= 10^6</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">力扣：圆圈中最后剩下的数字</a></p>
<p>思路：约瑟夫环问题<br>
code：</p>
<pre><code>class Solution {
    public int lastRemaining(int n, int m) {
        if(n&lt;0||m&lt;0) return -1;
        int last = 0;
        for (int i =2; i &lt;= n; i++) {
            last=(last+m)%i;
        }
        return last;
    }
}
</code></pre>
<h3 id="二-股票的最大利润">二、股票的最大利润</h3>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>示例 2:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>限制：0 &lt;= 数组长度 &lt;= 10^5</p>
<p>来源：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof">力扣：股票的最大利润</a></p>
<p>思路1：直接遍历所有<br>
code1：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length&lt;=0) return 0;
        int max = 0;
        for (int i = 0; i &lt; prices.length; i++) {
            int temp = 0;
            for (int j = i + 1; j &lt; prices.length; j++) {
                temp = temp &gt; prices[j] - prices[i] ? temp : prices[j] - prices[i];
            }
            max = max &gt; temp ? max : temp;
        }
        return max;
    }
}
</code></pre>
<p>思路2：优化思路1，找到一个最小的temp，然后更新max<br>
code2：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length&lt;=0) return 0;
        int max = 0;
        int temp=prices[0];
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i]&lt;temp) {
                temp=prices[i];
            }else if(prices[i]-temp&gt;max){
                max=prices[i]-temp;
            }
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day29：n个骰子的点数 & 扑克牌中的顺子]]></title>
        <id>https://southton.github.io/starry/post/day29/</id>
        <link href="https://southton.github.io/starry/post/day29/">
        </link>
        <updated>2020-03-13T07:49:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-n个骰子的点数">一、n个骰子的点数</h3>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p>示例 1:<br>
输入: 1<br>
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</p>
<p>示例 2:<br>
输入: 2<br>
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<br>
限制：1 &lt;= n &lt;= 11</p>
<p>来源：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof">力扣：n个骰子的点数</a></p>
<p>思路：动态规划<br>
F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)<br>
code:</p>
<pre><code>class Solution {
    public double[] twoSum(int n) {
        if (n &lt; 1)   return new double[0];
        double[] dp = new double[6*n + 1];
        double[] pr = new double[5*n + 1];//可能的点数和
        double sum=Math.pow(6, n);        
        for (int i = 1; i &lt;= 6; i++) {
            dp[i]=1;
            pr[i-1]=1.0/6;            
        }
        for (int i = 2; i &lt;= n; i++) {  //控制骰子个数
            for (int j = n*6; j &gt;=1; j--) {
                int temp=0;
                for (int k = 1; k &lt;= 6; k++) {
                    temp+=j&gt;=k?dp[j-k]:0;
                }
                dp[j]=temp;
                if (i==n&amp;&amp;j&gt;=n) pr[j-i]=dp[j]/sum;                
            }
        }
        return pr;
    }
}
</code></pre>
<h3 id="二-扑克牌中的顺子">二、 扑克牌中的顺子</h3>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例 1:<br>
输入: [1,2,3,4,5]<br>
输出: True</p>
<p>示例 2:<br>
输入: [0,0,1,2,5]<br>
输出: True</p>
<p>限制：数组长度为 5 &amp; 数组的数取值为 [0, 13] .</p>
<p>来源：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">力扣：扑克牌中的顺子</a></p>
<p>思路：排序，统计数组中0的个数，数组中若有两个数相等则不能构成顺子，数组中不连续的两个数之间缺的数字个数必须小于等于数组中0的个数<br>
code：</p>
<pre><code>class Solution {
    public boolean isStraight(int[] nums) {
        if(nums.length&lt;5) return false;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt; 0 || nums[i] &gt; 13) return false;               
        }
        int zero = 0;
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 1; i++) {
            if (nums[i] == 0) {
                zero++;
                continue;
            }
            if (nums[i] == nums[i + 1]) return false;                
            if (nums[i] != nums[i + 1] + 1) zero -= nums[i + 1] - nums[i] - 1;                
        }
        return zero &gt;= 0;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>