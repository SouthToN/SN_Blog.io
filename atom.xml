<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://southton.github.io/starry</id>
    <title>Starry</title>
    <updated>2020-03-17T02:36:37.056Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://southton.github.io/starry"/>
    <link rel="self" href="https://southton.github.io/starry/atom.xml"/>
    <logo>https://southton.github.io/starry/images/avatar.png</logo>
    <icon>https://southton.github.io/starry/favicon.ico</icon>
    <rights>All rights reserved 2020, Starry</rights>
    <entry>
        <title type="html"><![CDATA[Day33：二叉搜索树的最近公共祖先]]></title>
        <id>https://southton.github.io/starry/post/day33/</id>
        <link href="https://southton.github.io/starry/post/day33/">
        </link>
        <updated>2020-03-17T02:13:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-二叉搜索树的最近公共祖先-i">一、二叉搜索树的最近公共祖先 I</h3>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>
<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br>
<img src="https://southton.github.io/starry/post-images/1584411586366.png" alt="" loading="lazy"><br>
示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
<p>示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof">力扣：二叉搜索树的最近公共祖先 I</a></p>
<p>思路：对于二叉搜索树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，利用这一特性递归。<br>
code：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root==p || root == q)  return root;
        if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left, p, q);
        if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right, p, q);       
        return root;
    }
}
</code></pre>
<h3 id="二-二叉树的最近公共祖先-ii">二、二叉树的最近公共祖先 II</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>
<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br>
<img src="https://southton.github.io/starry/post-images/1584411737145.png" alt="" loading="lazy"><br>
示例 1:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof">力扣：二叉树的最近公共祖先 II</a></p>
<p>思路：递归<br>
code：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root==p || root == q)  return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);//递归左子树
        TreeNode right = lowestCommonAncestor(root.right, p, q);//递归右子树
        if(left==null) return right;
        if(right==null) return left;
        return root;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day32：构建乘积数组 & 把字符串转换成整数]]></title>
        <id>https://southton.github.io/starry/post/day32/</id>
        <link href="https://southton.github.io/starry/post/day32/">
        </link>
        <updated>2020-03-16T03:05:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-构建乘积数组">一、构建乘积数组</h3>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>示例:<br>
输入: [1,2,3,4,5]<br>
输出: [120,60,40,30,24]</p>
<p>提示：</p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li>a.length &lt;= 100000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">力扣：构建乘积数组</a></p>
<p>思路1：根据题目要求直接遍历，数组b的元素b[i]等于数组a中除a[i]外所有元素的乘积，也等于a中所有元素乘积除a[i]，又题目要求不能使用除法，故只能采用前者的思路，但是这样时间复杂度较高O(N^2)，力扣无法通过<br>
code1：</p>
<pre><code>class Solution {
    public int[] constructArr(int[] a) {
        if (a.length == 0) return new int[0];
        int len = a.length;
        int[] b = new int[len];
        int cur=0;
        while(cur&lt;len){
            int temp=1;
            for (int i = 0; i &lt; len; i++) {
                if(i!=cur) temp*=a[i];
            }            
            b[cur]=temp;
            cur++;
        }        
        return b;
    }
}
</code></pre>
<p>思路2：优化，数组b的元素b[i]等于数组a中除a[i]外所有元素的乘积，据此可将数组a从a[i]分左右两部分，b[i]就等于a[i]左边的累积结果乘右边累积结果,时间复杂度O（2N）。<br>
code2:</p>
<pre><code>class Solution {
    public int[] constructArr(int[] a) {
        if (a.length == 0) return new int[0];            
        int len = a.length;
        int[] b = new int[len];
        int temp = 1;// 左边累乘
        for (int i = 0; i &lt; len; i++) {
            b[i] = temp;
            temp *= a[i];
        }
        temp = 1;// 右边累乘
        for (int i = len - 1; i &gt;= 0; i--) {
            b[i] *= temp;
            temp *= a[i];
        }
        return b;
    }
}
</code></pre>
<h3 id="二-把字符串转换成整数">二、把字符串转换成整数</h3>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。<br>
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>
<code>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</code><br>
在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>
说明：<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:<br>
输入: &quot;42&quot;<br>
输出: 42</p>
<p>示例 2:<br>
输入: &quot;   -42&quot;<br>
输出: -42<br>
解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p>示例 3:<br>
输入: &quot;4193 with words&quot;<br>
输出: 4193<br>
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</p>
<p>示例 4:<br>
输入: &quot;words and 987&quot;<br>
输出: 0<br>
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。</p>
<p>示例 5:<br>
输入: &quot;-91283472332&quot;<br>
输出: -2147483648<br>
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">力扣：把字符串转换成整数</a></p>
<p>思路：注意考虑多种情况，例如符号，其他字符，溢出<br>
code：</p>
<pre><code>class Solution {
    public int strToInt(String str) {
        if (str==null||str.length() == 0) return 0;
        int len = str.length();
        int i = 0;
        boolean flag = true; // true:+,false:-
        while (i&lt;len&amp;&amp;str.charAt(i) == ' ' &amp;&amp; i &lt; len) {//去空格
            i++;
        }
        if(i&lt;len&amp;&amp; (str.charAt(i) == '+' || str.charAt(i) == '-')) {//判断正负            
            if (str.charAt(i) == '-')
                flag = false;
            i++;
        }
        long num = 0;
        while (i &lt; len &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') {//转换同时判断是否溢出
            num = num * 10 + str.charAt(i) - '0';            
            long temp = flag ? num : -num;
            if (temp &lt;= Integer.MIN_VALUE)
                return Integer.MIN_VALUE;
            if (temp &gt;= Integer.MAX_VALUE)
                return Integer.MAX_VALUE;
            i++;
        }        
        return (int) (flag?num:-num);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day31：求1+2+…+n & 不用加减乘除做加法]]></title>
        <id>https://southton.github.io/starry/post/day31/</id>
        <link href="https://southton.github.io/starry/post/day31/">
        </link>
        <updated>2020-03-15T03:32:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-求12n">一、求1+2+…+n</h3>
<p>求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：<br>
输入: n = 3<br>
输出: 6</p>
<p>示例 2：<br>
输入: n = 9<br>
输出: 45</p>
<p>限制：</p>
<ul>
<li>1 &lt;= n &lt;= 10000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof">力扣：求1+2+…+n</a></p>
<p>思路：使用递归，条件与 &amp;&amp; 在第一个条件语句为 false 的情况下不会去执行第二个条件语句。<br>
code：</p>
<pre><code>class Solution {
    public int sumNums(int n) {
        // return n*(n+1)/2;
        int sum = n;
        boolean b = (n &gt; 0) &amp;&amp; ((sum += sumNums(n - 1)) &gt; 0);
        return sum;
    }
}
</code></pre>
<h3 id="二-不用加减乘除做加法">二、不用加减乘除做加法</h3>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>示例:<br>
输入: a = 1, b = 1<br>
输出: 2</p>
<p>提示：</p>
<ul>
<li>a, b 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof">力扣：不用加减乘除做加法</a></p>
<p>思路：位运算<br>
code：</p>
<pre><code>class Solution {
    public int add(int a, int b) {
        while(b != 0){
            int temp = a ^ b; //按位异或
            b = (a &amp; b) &lt;&lt; 1; //进位
            a = temp;
        }
        return a;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day30： 圆圈中最后剩下的数字 & 股票的最大利润]]></title>
        <id>https://southton.github.io/starry/post/day30/</id>
        <link href="https://southton.github.io/starry/post/day30/">
        </link>
        <updated>2020-03-14T04:36:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-圆圈中最后剩下的数字">一、圆圈中最后剩下的数字</h3>
<p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：<br>
输入: n = 5, m = 3<br>
输出: 3</p>
<p>示例 2：<br>
输入: n = 10, m = 17<br>
输出: 2<br>
限制：</p>
<ul>
<li>1 &lt;= n &lt;= 10^5</li>
<li>1 &lt;= m &lt;= 10^6</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">力扣：圆圈中最后剩下的数字</a></p>
<p>思路：约瑟夫环问题<br>
code：</p>
<pre><code>class Solution {
    public int lastRemaining(int n, int m) {
        if(n&lt;0||m&lt;0) return -1;
        int last = 0;
        for (int i =2; i &lt;= n; i++) {
            last=(last+m)%i;
        }
        return last;
    }
}
</code></pre>
<h3 id="二-股票的最大利润">二、股票的最大利润</h3>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>示例 2:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>限制：0 &lt;= 数组长度 &lt;= 10^5</p>
<p>来源：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof">力扣：股票的最大利润</a></p>
<p>思路1：直接遍历所有<br>
code1：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length&lt;=0) return 0;
        int max = 0;
        for (int i = 0; i &lt; prices.length; i++) {
            int temp = 0;
            for (int j = i + 1; j &lt; prices.length; j++) {
                temp = temp &gt; prices[j] - prices[i] ? temp : prices[j] - prices[i];
            }
            max = max &gt; temp ? max : temp;
        }
        return max;
    }
}
</code></pre>
<p>思路2：优化思路1，找到一个最小的temp，然后更新max<br>
code2：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length&lt;=0) return 0;
        int max = 0;
        int temp=prices[0];
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i]&lt;temp) {
                temp=prices[i];
            }else if(prices[i]-temp&gt;max){
                max=prices[i]-temp;
            }
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day29：n个骰子的点数 & 扑克牌中的顺子]]></title>
        <id>https://southton.github.io/starry/post/day29/</id>
        <link href="https://southton.github.io/starry/post/day29/">
        </link>
        <updated>2020-03-13T07:49:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-n个骰子的点数">一、n个骰子的点数</h3>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p>示例 1:<br>
输入: 1<br>
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</p>
<p>示例 2:<br>
输入: 2<br>
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<br>
限制：1 &lt;= n &lt;= 11</p>
<p>来源：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof">力扣：n个骰子的点数</a></p>
<p>思路：动态规划<br>
F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)<br>
code:</p>
<pre><code>class Solution {
    public double[] twoSum(int n) {
        if (n &lt; 1)   return new double[0];
        double[] dp = new double[6*n + 1];
        double[] pr = new double[5*n + 1];//可能的点数和
        double sum=Math.pow(6, n);        
        for (int i = 1; i &lt;= 6; i++) {
            dp[i]=1;
            pr[i-1]=1.0/6;            
        }
        for (int i = 2; i &lt;= n; i++) {  //控制骰子个数
            for (int j = n*6; j &gt;=1; j--) {
                int temp=0;
                for (int k = 1; k &lt;= 6; k++) {
                    temp+=j&gt;=k?dp[j-k]:0;
                }
                dp[j]=temp;
                if (i==n&amp;&amp;j&gt;=n) pr[j-i]=dp[j]/sum;                
            }
        }
        return pr;
    }
}
</code></pre>
<h3 id="二-扑克牌中的顺子">二、 扑克牌中的顺子</h3>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例 1:<br>
输入: [1,2,3,4,5]<br>
输出: True</p>
<p>示例 2:<br>
输入: [0,0,1,2,5]<br>
输出: True</p>
<p>限制：数组长度为 5 &amp; 数组的数取值为 [0, 13] .</p>
<p>来源：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">力扣：扑克牌中的顺子</a></p>
<p>思路：排序，统计数组中0的个数，数组中若有两个数相等则不能构成顺子，数组中不连续的两个数之间缺的数字个数必须小于等于数组中0的个数<br>
code：</p>
<pre><code>class Solution {
    public boolean isStraight(int[] nums) {
        if(nums.length&lt;5) return false;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt; 0 || nums[i] &gt; 13) return false;               
        }
        int zero = 0;
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 1; i++) {
            if (nums[i] == 0) {
                zero++;
                continue;
            }
            if (nums[i] == nums[i + 1]) return false;                
            if (nums[i] != nums[i + 1] + 1) zero -= nums[i + 1] - nums[i] - 1;                
        }
        return zero &gt;= 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day28：翻转单词顺序和左旋转字符串 & 滑动窗口的最大值和队列的最大值 ]]></title>
        <id>https://southton.github.io/starry/post/day28/</id>
        <link href="https://southton.github.io/starry/post/day28/">
        </link>
        <updated>2020-03-12T02:01:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-翻转单词顺序">一、翻转单词顺序</h3>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</p>
<p>示例 1：<br>
输入: &quot;the sky is blue&quot;<br>
输出: &quot;blue is sky the&quot;</p>
<p>示例 2：<br>
输入: &quot;  hello world!  &quot;<br>
输出: &quot;world! hello&quot;<br>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：<br>
输入: &quot;a good   example&quot;<br>
输出: &quot;example good a&quot;<br>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>
说明：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">力扣：翻转单词顺序</a></p>
<p>思路：trim（） 去除字符串前缀和后缀空格<br>
&quot;\s+&quot; 正则表达式(正则表达式中\s匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</p>
<ul>
<li>\f -&gt; 匹配一个换页</li>
<li>\n -&gt; 匹配一个换行符</li>
<li>\r -&gt; 匹配一个回车符</li>
<li>\t -&gt; 匹配一个制表符</li>
<li>\v -&gt; 匹配一个垂直制表符</li>
</ul>
<p>而“\s+”则表示匹配任意多个上面的字符。另因为&quot;&quot;在Java里是转义字符，所以在Java里用“\s+”.)<br>
code:</p>
<pre><code>class Solution {
    public String reverseWords(String s) {
        String[] str = s.trim().split(&quot;\\s+&quot;);
        int start=0;        
        int end = str.length - 1;
        while (start &lt; end) {
            String tmp = str[start];
            str[start] = str[end];
            str[end] = tmp;
            start++;
            end--;
        }              
        return String.join(&quot; &quot;, str);
    }
}
</code></pre>
<h3 id="二-左旋转字符串">二、左旋转字符串</h3>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
<p>示例 1：<br>
输入: s = &quot;abcdefg&quot;, k = 2<br>
输出: &quot;cdefgab&quot;</p>
<p>示例 2：<br>
输入: s = &quot;lrloseumgh&quot;, k = 6<br>
输出: &quot;umghlrlose&quot;</p>
<p>限制：1 &lt;= k &lt; s.length &lt;= 10000</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">力扣：左旋转字符串</a></p>
<p>思路1：用两个String数组<br>
code1：</p>
<pre><code>class Solution {
    public String reverseLeftWords(String s, int n) {
        if(n&lt;=0) return s;
        String [] str = s.split(&quot;&quot;); 
        int start=0; 
        String [] str2 = new String[str.length];              
        for (int i = n; i &lt; str.length; i++) {
            str2[start++]=str[i];
        }
        for (int i = 0; i &lt; n; i++) {
            str2[start++]=str[i];
        }  
        return String.join(&quot;&quot;, str2);
    }
}
</code></pre>
<p>思路2：<br>
code2：</p>
<pre><code>class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n) + s.substring(0, n);
    }
}
</code></pre>
<h3 id="三-滑动窗口的最大值">三、滑动窗口的最大值</h3>
<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:<br>
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>
输出: [3,3,5,5,6,7]<br>
解释:</p>
<pre><code>  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>来源：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">力扣：滑动窗口的位置</a></p>
<p>思路：外层for控制窗口的移动，内层for负责找出最大值<br>
code：</p>
<pre><code>class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (k &lt;= 0) return nums;
        List result = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt;= nums.length-k; i++) {
            int max=nums[i];
            for (int j = i; j &lt; k+i; j++) {
                max=Math.max(max, nums[j]);
            }
            result.add(max);            
        }
        int[] results =new int[result.size()];
        for (int j = 0; j &lt; results.length; j++) {
            results[j]=(int)result.get(j);
        }
        return results;
    }
}
</code></pre>
<h3 id="四-队列的最大值">四、队列的最大值</h3>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>
若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：<br>
输入:<br>
[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]<br>
[[],[1],[2],[],[],[]]<br>
输出: [null,null,null,2,1,2]</p>
<p>示例 2：<br>
输入:<br>
[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]<br>
[[],[],[]]<br>
输出: [null,-1,-1]</p>
<p>限制：</p>
<ul>
<li>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</li>
<li>1 &lt;= value &lt;= 10^5</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">力扣：队列的最大值</a><br>
思路：<br>
code：</p>
<pre><code>class MaxQueue {
    private Deque&lt;Integer&gt; data = null;
    private Deque&lt;Integer&gt; max = null;    
    public MaxQueue() {
        data = new ArrayDeque&lt;&gt;();
        max = new ArrayDeque&lt;&gt;();
    }
    
    public int max_value() {
        if(max.isEmpty()) return -1;
        return max.peekFirst();
    }
    
    public void push_back(int value) {
        while(!max.isEmpty() &amp;&amp; value &gt; max.peekLast()) max.pollLast();        
        max.offerLast(value);
        data.offerLast(value);
    }
    
    public int pop_front() {
        if(data.isEmpty()) return -1;int value = data.pollFirst();
        if(max.peekFirst() == value) max.pollFirst();
        return value;
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day27：数组中数字出现的次数 & 和为s的两个数字]]></title>
        <id>https://southton.github.io/starry/post/day27/</id>
        <link href="https://southton.github.io/starry/post/day27/">
        </link>
        <updated>2020-03-11T04:37:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-数组中数字出现的次数">一、数组中数字出现的次数</h3>
<p>（1）数组中数字出现的次数 I<br>
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例 1：<br>
输入：nums = [4,1,4,6]<br>
输出：[1,6] 或 [6,1]</p>
<p>示例 2：<br>
输入：nums = [1,2,10,4,1,4,3,3]<br>
输出：[2,10] 或 [10,2]<br>
限制：</p>
<ul>
<li>2 &lt;= nums &lt;= 10000</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">力扣：数组中数字出现的次数 I</a></p>
<p>思路：利用hashset<br>
code：</p>
<pre><code>class Solution {
    public int[] singleNumbers(int[] nums) {
       if (nums.length == 0) return new int[0];         
        HashSet hashset=new HashSet();
        for (int i = 0; i &lt; nums.length; i++) {
            if (hashset.contains(nums[i])) {
                hashset.remove(nums[i]);
            } else {
                hashset.add(nums[i]);
            }
        }       
        int [] result = new int[2];
        for (int i = 0; i &lt; hashset.size(); i++) {
            result[i]=Integer.parseInt(hashset.toArray()[i].toString());
        }
        return result;
    }
}
</code></pre>
<p>（2）数组中数字出现的次数 II<br>
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例 1：<br>
输入：nums = [3,4,3,3]<br>
输出：4</p>
<p>示例 2：<br>
输入：nums = [9,1,7,9,7,9,7]<br>
输出：1</p>
<p>限制：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 10000</li>
<li>1 &lt;= nums[i] &lt; 2^31</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">力扣：数组中数字出现的次数 II</a></p>
<p>思路1：循环遍历统计每个数字出现的次数<br>
code1：</p>
<pre><code>class Solution {
    public int singleNumber(int[] nums) {
        if (nums.length == 0) return 0;
        for (int i = 0; i &lt; nums.length; i++) {
            int count = 0;
            for (int j = 0; j &lt; nums.length; j++) {
                if (nums[i] == nums[j]) count++;                
            }
            if (count == 1) return nums[i];
        }
        return 0;
    }
}
</code></pre>
<p>思路2：借助hashmap统计每个数字出现的次数<br>
code2:</p>
<pre><code>class Solution {
    public int singleNumber(int[] nums) {
        if (nums.length == 0) return 0;
        Map&lt;Integer,Integer&gt; hm= new HashMap&lt;&gt;();
        for (int num : nums) {
            hm.put(num, hm.getOrDefault(num, 0)+1);
        }
        for (int num : nums) {
            if(hm.get(num)==1) return num;
        }
        return 0;
    }
}
</code></pre>
<h3 id="二-和为s的两个数字">二、和为s的两个数字</h3>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：<br>
输入：nums = [2,7,11,15], target = 9<br>
输出：[2,7] 或者 [7,2]</p>
<p>示例 2：<br>
输入：nums = [10,26,30,31,47,60], target = 40<br>
输出：[10,30] 或者 [30,10]</p>
<p>限制：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 10^5</li>
<li>1 &lt;= nums[i] &lt;= 10^6</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof">力扣：和为s的两个数字</a></p>
<p>思路1：直接遍历，由于递增排序，可以先找大的，然后遍历找小的<br>
code1：</p>
<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums.length == 0) return new int[0];            
        int[] result = new int[2];        
        for (int i = nums.length - 1; i &gt; 0; i--) {
            if (target - nums[i] &lt;= 0) continue; 
            for (int j = 0; j &lt; i; j++) {
                if (nums[j] == target-nums[i]) {
                    result[0] = nums[j];
                    result[1] = nums[i];                    
                    return result;
                }
            }
        }
        return result;
    }
}
</code></pre>
<p>思路2：利用双指针，从两端往中间扫描<br>
code2：</p>
<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums.length == 0) return new int[0];            
        int[] result = new int[2];  
        int start=0,end=nums.length-1;
        while(start&lt;end){
            int sum=nums[start]+nums[end];
            if (sum==target) {
                result[0]=nums[start];
                result[1]=nums[end];
            }
            if(sum&gt;target){
                end--;
            }else start++;
        }       
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day26：二叉搜索树的第k大节点 & 二叉树的深度和平衡二叉树]]></title>
        <id>https://southton.github.io/starry/post/day26/</id>
        <link href="https://southton.github.io/starry/post/day26/">
        </link>
        <updated>2020-03-10T07:32:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-二叉搜索树的第k大节点">一、二叉搜索树的第k大节点</h3>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例 1:<br>
输入: root = [3,1,4,null,2], k = 1<br>
<img src="https://southton.github.io/starry/post-images/1583995037571.png" alt="" loading="lazy"><br>
输出: 4</p>
<p>示例 2:<br>
输入: root = [5,3,6,2,4,null,null,1], k = 3<br>
<img src="https://southton.github.io/starry/post-images/1583995053171.png" alt="" loading="lazy"><br>
输出: 4<br>
限制：1 ≤ k ≤ 二叉搜索树元素个数</p>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">力扣：二叉搜索树的第k大节点</a></p>
<p>思路1：直接遍历，按右根左的顺序中序遍历整棵树<br>
code1:</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List tree = new ArrayList&lt;Integer&gt;();
    public int kthLargest(TreeNode root, int k) {
        if (root == null) return 0;
        rightFirst(root);
        int val = -1;
        for (int i = 0; i &lt; k; i++) {
            val = (int) tree.get(i);
        }
        return val;
    }
    public void rightFirst(TreeNode node) {
        if (node != null) {
            rightFirst(node.right);
            tree.add(node.val);
            rightFirst(node.left);
        }
    }
}
</code></pre>
<p>思路2：不需要遍历完，遍历到第k大即停止<br>
code2：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int count=0,val=0;
    public int kthLargest(TreeNode root, int k) {
    if (root == null)
        return 0;
    rightFirst(root,k);    
    return val;
    }

    public void rightFirst(TreeNode node,int k) {
        if (node != null) {
            rightFirst(node.right,k);
            if(++count==k){
                val=node.val;
                return;
            }
            rightFirst(node.left,k);
        }
    }
}
</code></pre>
<h3 id="二-二叉树的深度和平衡二叉树">二、二叉树的深度和平衡二叉树</h3>
<p>（1）二叉树的深度<br>
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
<img src="https://southton.github.io/starry/post-images/1583994937310.png" alt="" loading="lazy"><br>
返回它的最大深度 3 。<br>
提示：节点总数 &lt;= 10000</p>
<p>来源：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">力扣：二叉树的深度</a></p>
<p>思路1：从根节点分别递归遍历左右子树<br>
code:</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
</code></pre>
<p>思路2：层序遍历<br>
code2：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        
        queue.add(root);
        TreeNode last=root;
        TreeNode cur;
        int count =0;
        while (!queue.isEmpty()) {
            cur = queue.poll();
            //System.out.print(root.val + &quot; &quot;);
            if (cur.left != null) queue.add(cur.left);
            if (cur.right != null) queue.add(cur.right);
            if(cur==last){
                last=queue.peekLast();
                ++count;
            }           
        }
        return count;
    }
}
</code></pre>
<p>（2）平衡二叉树<br>
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
<img src="https://southton.github.io/starry/post-images/1583994870436.png" alt="" loading="lazy"><br>
返回 true 。<br>
示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]<br>
<img src="https://southton.github.io/starry/post-images/1583994882199.png" alt="" loading="lazy"><br>
返回 false 。<br>
限制：1 &lt;= 树的结点个数 &lt;= 10000</p>
<p>来源：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">力扣：平衡二叉树</a></p>
<p>思路：递归计算每个节点的深度<br>
code:</p>
<pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null) return true;
        if(Math.abs(maxDepth(root.left)-maxDepth(root.right))&lt;=1) return isBalanced(root.left)&amp;&amp;isBalanced(root.right);
        return false;
    }

    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day25：两个链表的第一个公共节点 & 0～n-1中缺失的数字]]></title>
        <id>https://southton.github.io/starry/post/day25/</id>
        <link href="https://southton.github.io/starry/post/day25/">
        </link>
        <updated>2020-03-09T05:27:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-两个链表的第一个公共节点">一、两个链表的第一个公共节点</h3>
<p>输入两个链表，找出它们的第一个公共节点。<br>
如下面的两个链表：<br>
<img src="https://southton.github.io/starry/post-images/1583994703207.png" alt="" loading="lazy"><br>
在节点 c1 开始相交。</p>
<p>示例 1：<br>
<img src="https://southton.github.io/starry/post-images/1583994712889.png" alt="" loading="lazy"><br>
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>
输出：Reference of the node with value = 8<br>
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：<br>
<img src="https://southton.github.io/starry/post-images/1583994723541.png" alt="" loading="lazy"><br>
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>
输出：Reference of the node with value = 2<br>
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br>
<img src="https://southton.github.io/starry/post-images/1583994735923.png" alt="" loading="lazy"><br>
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>
输出：null<br>
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>
解释：这两个链表不相交，因此返回 null。</p>
<p><code>注意：</code></p>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<p>来源：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">力扣：两个链表的第一个公共节点</a></p>
<p>思路1：计算两个链表的长度差,从长度相等的地方开始找<br>
code1：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode lnA = headA;
        ListNode lnB = headB;
        int la = 0, lb = 0;
        while (lnA.next != null) {// 统计A的长度
            la++;
            lnA = lnA.next;
        }
        while (lnB.next != null) {// 统计B的长度
            lb++;
            lnB = lnB.next;
        }
        if (lnA != lnB) return null;// 如果最后一个节点不相等则无公共节点
        lnA = headA; //计算长度时修改过，此时重新赋值
        lnB = headB;
        int n = 0;
        if (la &gt; lb) { //移动到长度相等处
            n = la - lb;
            while (n-- &gt; 0) {
                lnA = lnA.next;
            }
        } else {
            n = lb - la;
            while (n-- &gt; 0) {
                lnB = lnB.next;
            }
        }
        while (lnA != lnB) {//从相等长度处开始找
            lnA = lnA == null ? null : lnA.next;
            lnB = lnB == null ? null : lnB.next;
        }
        return lnA;
    }
}
</code></pre>
<p>思路二：双指针，headA无重复部分长度+公共长度+headB无重复部分长度=headB无重复部分长度+公共长度+headA无重复部分长度<br>
code2：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
       if (headA == null || headB == null) return null;            
        ListNode ln1 = headA;
        ListNode ln2 = headB;
        while (ln1 != ln2) {
            ln1 = ln1 == null ? headB : ln1.next;
            ln2 = ln2 == null ? headA : ln2.next;
        }
        return ln1; 
    }
}
</code></pre>
<h3 id="二-0~n-1中缺失的数字">二、0～n-1中缺失的数字</h3>
<p>（1）在排序数组中查找数字 I<br>
统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:<br>
输入: nums = [5,7,7,8,8,10], target = 8<br>
输出: 2</p>
<p>示例 2:<br>
输入: nums = [5,7,7,8,8,10], target = 6<br>
输出: 0</p>
<p>来源：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof">力扣：在排序数组中查找数字 I</a><br>
思路：<br>
code：</p>
<pre><code>class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 0) return 0;
        int count = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] == target) count++;
        }
        return count;
    }
}
</code></pre>
<p>（2）0～n-1中缺失的数字<br>
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:<br>
输入: [0,1,3]<br>
输出: 2</p>
<p>示例 2:<br>
输入: [0,1,2,3,4,5,6,7,9]<br>
输出: 8</p>
<p>来源：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">力扣：0～n-1中缺失的数字</a></p>
<p>思路：<br>
code：</p>
<pre><code>class Solution {
    public int missingNumber(int[] nums) {
        for(int i=0;i&lt;nums.length;i++){
            if(nums[i]!=i) return i;
        }
        return nums.length;
    }
}
</code></pre>
<p>os: 0～n-1中缺失的数字应该得用上排序这个规律</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day24：第一个只出现一次的字符 & 数组中的逆序对]]></title>
        <id>https://southton.github.io/starry/post/day24/</id>
        <link href="https://southton.github.io/starry/post/day24/">
        </link>
        <updated>2020-03-08T03:25:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-第一个只出现一次的字符">一、第一个只出现一次的字符</h3>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<p>示例:<br>
s = &quot;abaccdeff&quot;<br>
返回 &quot;b&quot;<br>
s = &quot;&quot;<br>
返回 &quot; &quot;</p>
<p>来源：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">力扣：第一个只出现一次的字符</a></p>
<p>思路1：直接遍历，时间复杂度O(n)，空间复杂度O(1)<br>
code1：</p>
<pre><code>class Solution {
    public char firstUniqChar(String s) {
        if (s.length() == 0) return ' ';
        int[] dict = new int[26];
        for (int i = 0; i &lt; s.length(); i++) {//统计每个字符出现的次数
            dict[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i &lt; s.length(); i++) {
            if (dict[s.charAt(i) - 'a'] == 1) {//找出第一个只出现一次的字符
                return s.charAt(i);
            }
        }
        return ' ';
    }
}
</code></pre>
<h3 id="二-数组中的逆序对">二、数组中的逆序对</h3>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例 1:<br>
输入: [7,5,6,4]<br>
输出: 5</p>
<p>来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">力扣：数组中的逆序对</a></p>
<p>思路：利用归并排序的排序过程进行统计逆序对的个数<br>
code：</p>
<pre><code>class Solution {
    private long sum; // 统计逆序对的个数
    public int reversePairs(int[] nums) {
        if(nums.length==0) return 0;
        sum = 0;
        int l = 0;
        int r = nums.length - 1;
        divide(l, r, nums);
        return (int)sum;
    }    
    public void divide(int l, int r, int[] nums) {
        if (l != r) {
            int mid = (l + r) &gt;&gt; 1;
            divide(l, mid, nums);
            divide(mid + 1, r, nums);
            merge(l, r, mid, nums);
        }
    }
    public void merge(int l, int r, int mid, int[] nums) {
        int i = l; // 左区间的起点
        int j = mid + 1; // 右区间的起点
        int[] temp = new int[r - l + 1];
        int index = 0;
        while (i &lt;= mid &amp;&amp; j &lt;= r) {
            if (nums[i] &gt; nums[j]) {
                temp[index++] = nums[j++];
                sum += mid - i + 1; // 统计逆序对个数
            } else {
                temp[index++] = nums[i++];
            }
        }
        while (i &lt;= mid) temp[index++] = nums[i++];
        while (j &lt;= r) temp[index++] = nums[j++];
        index = 0;
        for (int k = l; k &lt;= r; k++) {
            nums[k] = temp[index++];
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>